<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TorahMoment — In-Depth Shiurim</title>

  <style>
    html, body { margin:0; padding:0; }
*, *::before, *::after { box-sizing:border-box; }

    :root{
      --bg:#f7f7f8;
      --card:#ffffff;
      --text:#111;
      --muted:#666;
      --border:#e7e7ee;
      --accent:#0d9488;
      --shadow:0 6px 22px rgba(0,0,0,0.07);
      --radius:16px;
       /* Per-page layout alignment (set these to match THAT page’s .wrap) */
      /* Example values below — change per page */
      --tm-wrap-max: 1060px;
      --tm-wrap-pad: 22px;
    }

    *, *::before, *::after{ box-sizing: border-box; }

    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:1060px;margin:0 auto;padding:22px;}
    .top{display:flex;justify-content:space-between;align-items:flex-end;gap:16px;flex-wrap:wrap;}
    h1{margin:0;font-size:28px;letter-spacing:-0.02em;}
    .sub{color:var(--muted);margin-top:6px;font-size:14px;}

    .pillbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:16px;}
    .pill{border:1px solid var(--border);background:#fff;border-radius:999px;padding:8px 12px;font-size:14px;cursor:pointer;}
    .pill[aria-pressed="true"]{border-color:rgba(13,148,136,.35);box-shadow:0 2px 10px rgba(0,0,0,0.05);}

    
    .sectionTitle{display:flex;align-items:baseline;gap:10px;flex-wrap:wrap;}
    .sectionTitle h2{margin:0;font-size:18px;}
    .count{color:var(--muted);font-size:13px;}

    .list{margin-top:10px;display:flex;flex-direction:column;gap:8px;}
    .row{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:12px;border:1px solid var(--border);border-radius:14px;background:#fff;
      text-decoration:none;color:inherit;
    }
    .row:hover{transform:translateY(-1px);}
    .left{min-width:0;flex:1;}
    .title{font-weight:750;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .meta{margin-top:3px;color:var(--muted);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

    .right{display:flex;align-items:center;gap:8px;flex:0 0 auto;}
    .badge{font-size:12px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:#fff;}
    .badgeLong{border-color:rgba(13,148,136,.35);}
    .badgeDur{color:var(--muted);}

    .muted{color:var(--muted);}

    .loader{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:14px;}
    .dot{width:8px;height:8px;border-radius:50%;background:var(--muted);opacity:.35;animation:pulse 1.2s infinite;}
    .dot:nth-child(2){animation-delay:.2s}
    .dot:nth-child(3){animation-delay:.4s}
    @keyframes pulse{0%,100%{opacity:.25}50%{opacity:.7}}

  /* ===== TorahMoment Topbar ===== */
.tm-topbar{
  width:100%;
  background:#ffffff;
  border-bottom:1px solid var(--border, #e7e7ee);
  position:sticky;
  top:0;
  z-index:1000;
}

.tm-topbar-inner{
  box-sizing: border-box; /* critical: match wrap sizing */
  max-width: var(--tm-wrap-max, 980px);
  margin:0 auto;
  padding:10px var(--tm-wrap-pad, 20px);
  display:flex;
  align-items:center;
  flex-wrap:nowrap;          /* never wrap */
  overflow-x:auto;           /* swipe on mobile */
  -webkit-overflow-scrolling:touch;
  scrollbar-width:none;
  position:relative;         /* for fade overlay */
}

.tm-topbar-inner::-webkit-scrollbar{ display:none; }

/* right-edge fade hint */
.tm-topbar-inner::after{
  content:"";
  position:absolute;
  right:0;
  top:0;
  width:28px;
  height:100%;
  pointer-events:none;
  background:linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,1));
}

/* links (force consistent color incl. visited) */
.tm-topbar a,
.tm-topbar a:visited{
  text-decoration:none;
  color:var(--muted, #666);
  font-size:14px;
  font-weight:500;
  white-space:nowrap;
  padding:4px 10px;
}

.tm-topbar a:hover{ color:var(--accent, #0d9488); }

/* Accessible active state: pill background (NOT color-only) */
/* Excludes home icon */
.tm-topbar a.active:not(.home-link),
.tm-topbar a.active:not(.home-link):visited{
  background: rgba(13,148,136,0.12);
  color: var(--text, #111) !important;
  font-weight: 600;
  border-radius: 999px;
}

/* separators */
.tm-topbar a + a{
  border-left:1px solid #e5e7eb;
  margin-left:6px;
  padding-left:12px;
}

/* home icon */
.tm-topbar .home-link{
  display:flex;
  align-items:center;
  justify-content:center;
  padding:4px 10px;
}
.tm-topbar .home-link svg{
  width:18px;
  height:18px;
}

/* Mobile tighten + “One Minute” -> “One-Min” */
@media (max-width: 520px){
  .tm-topbar-inner{ padding:8px var(--tm-wrap-pad, 12px); }
  .tm-topbar a, .tm-topbar a:visited{ font-size:13px; padding:3px 8px; }
  .tm-topbar a + a{ margin-left:5px; padding-left:10px; }

  .tm-topbar a[href$="/one-minute-audio.html"]{ font-size:0; }
  .tm-topbar a[href$="/one-minute-audio.html"]::before{
    content:"One-Min";
    font-size:13px;
  }
}

    .sectionToggle{
  width:100%;
  display:flex;
  align-items:center;
  gap:12px;
  background:none;
  border:none;
  padding:0;
  font-size:18px;
  font-weight:700;
  cursor:pointer;
  margin-bottom:10px;
}

.sectionChevron{
  margin-left:auto;
  transition: transform .2s ease;
  font-size:16px;
  color:var(--muted);
}

.sectionContent{
  overflow:hidden;
  transition: max-height .3s ease, opacity .2s ease;
}

.sectionContent.collapsed{
  max-height:0;
  opacity:0;
  pointer-events:none;
}

.sectionContent.expanded{
  max-height:2000px;
  opacity:1;
}

.sectionChevron.rotated{
  transform: rotate(180deg);
}


/* ===== Canonical Card Pattern ===== */

.card{
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  margin-bottom: 20px;
  overflow: hidden;
}

.sectionToggle{
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 14px 16px;
  background: transparent;
  border: 0;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 600;
}

.sectionToggle:hover{
  background: rgba(0,0,0,0.02);
}

.sectionChevron{
  font-size: 0.9rem;
  color: var(--muted);
}

.count{
  font-size: 0.8rem;
  color: var(--muted);
}

.sectionContent{
  padding: 0 16px 12px;
}


 .list > *{
  padding: 10px 0;
  border-top: 1px solid var(--border);
}

.list > *:first-child{
  border-top: 0;
}

.list {padding: 14px 16px;}    

/* Rows now contain inline audio */
.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:14px 16px;
  border:1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card);
  margin-bottom: 10px;
  cursor:pointer;
}

.left{ min-width:0; }
.title{ font-weight:600; }
.meta{ color: var(--muted); font-size: 0.85rem; margin-top:2px; }

.right{
  display:flex;
  align-items:center;
  gap:10px;
  flex:0 0 auto;
}

.badge{
  border:1px solid var(--border);
  border-radius:999px;
  padding:4px 10px;
  font-size:0.75rem;
  color: var(--muted);
  background:#fff;
}

.openLink{
  text-decoration:none;
  color: var(--muted);
  border:1px solid var(--border);
  border-radius:999px;
  padding:4px 10px;
  font-size:0.8rem;
}
.openLink:hover{ color: var(--accent); border-color: var(--accent); }

/* hidden until opened */
.audioWrap{ display:none; width:100%; margin-top:10px; }
.row.isOpen{ flex-wrap:wrap; }
.row.isOpen .audioWrap{ display:block; }
.audioWrap audio{ width:100%; }


 /* ===== Make In-Depth lists look like Mishna ===== */

.listCard{
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  overflow: hidden;
}

/* rows become flat items */
.listCard .row{
  margin: 0;
  border: 0;
  border-radius: 0;
  box-shadow: none;
  background: transparent;
  padding: 12px 14px;
  border-bottom: 1px solid var(--border);
}

.listCard .row:last-child{
  border-bottom: 0;
}

/* subtle hover */
@media (hover:hover){
  .listCard .row:hover{
    background: rgba(0,0,0,0.02);
    transform: none; /* kill lift */
  }
}

/* audio stays inline, just spaced nicely */
.listCard .row.isOpen .audioWrap{
  display:block;
  width:100%;
  margin-top:8px;
}

.listCard .audioWrap audio{
  width:100%;
}   

/* calmer section header like mishna */
.sectionToggle{
  padding: 12px 14px;
}

.sectionContent{
  padding: 10px 0 14px; /* remove side padding so listCard aligns perfectly */
}

    .controls .speedBtns{ display:none; gap:8px; flex-wrap:wrap; margin-top:8px; }
.row.isOpen .controls .speedBtns{ display:flex; }

.speedBtns button{
  border:1px solid var(--border);
  background:#fff;
  padding:4px 10px;
  border-radius:999px;
  font-size:0.75rem;
  cursor:pointer;
}
.speedBtns button.active{
  border-color: var(--accent);
  background: rgba(13,148,136,0.10);
  font-weight:700;
}

    
  </style>
</head>

<body>
  <div class="tm-topbar">
  <div class="tm-topbar-inner">
    <a href="https://torahmoment.com" aria-label="Home" class="home-link">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M3 10.5L12 3l9 7.5"></path>
        <path d="M5 10v10h14V10"></path>
      </svg>
    </a>

    <a href="https://torahmoment.com/parsha.html">Parsha</a>
    <a href="https://torahmoment.com/halacha.html">Halacha</a>
    <a href="https://torahmoment.com/one-minute-audio.html">One Minute</a>
    <a href="https://torahmoment.com/tefilah.html">Tefila</a>
    <a href="https://torahmoment.com/mishna.html">Mishna</a>
  </div>
</div>

  <div class="wrap">
    <div class="top">
      <div>
        <h1>In-Depth Shiurim</h1>
        <div class="sub">One place for the more serious / developed TorahMoment shiurim.</div>
      </div>
      <div class="muted" id="status">Loading…</div>
    </div>

    <div class="pillbar">
      <button class="pill" id="tabAll" aria-pressed="true" type="button">All</button>
      <button class="pill" id="tabParsha" aria-pressed="false" type="button">Parsha In-Depth</button>
      <button class="pill" id="tabHalacha" aria-pressed="false" type="button">Halacha / Hashkafa</button>
    </div>

<div class="card" id="parshaCard">

  <button class="sectionToggle" type="button">
    <span>Parsha In-Depth</span>
    <span class="sectionChevron">⌄</span>
    <span class="count" id="parshaCount"></span>
  </button>

  <div class="sectionContent" id="parshaContent">

    <div class="listCard">
    <div class="list" id="parshaList">
      <div class="loader">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
        Loading Parsha in-depth…
      </div>
    </div>
    </div>
  </div>

</div>


<div class="card" id="halachaCard">

  <button class="sectionToggle" type="button">
    <span>Halacha / Hashkafa — Long Shiurim</span>
    <span class="sectionChevron">⌄</span>
    <span class="count" id="halachaCount"></span>
  </button>

  <div class="sectionContent" id="halachaContent">
    <div class="listCard">
    <div class="list" id="halachaList">
      <div class="loader">
        <span class="dot"></span><span class="dot"></span><span class="dot"></span>
        Loading Halacha data…
      </div>
    </div>
    </div>  
  </div>

  <div class="sub" style="margin-top:10px;">
    Long = 10 minutes or more (based on audio metadata).
  </div>

</div>


<script>
  const LONG_SEC = 600;

  // Parsha order (full Torah order)
  const PARSHA_ORDER = [
    "Bereishis","Noach","Lech Lecha","Vayeira","Chayei Sarah","Toldos","Vayeitzei","Vayishlach","Vayeishev","Miketz","Vayigash","Vayechi",
    "Shemos","Va'eira","Bo","Beshalach","Yisro","Mishpatim","Terumah","Tetzaveh","Ki Sisa","Vayakhel","Pekudei",
    "Vayikra","Tzav","Shemini","Tazria","Metzora","Achrei Mos","Kedoshim","Emor","Behar","Bechukosai",
    "Bamidbar","Naso","Beha'aloscha","Shelach","Korach","Chukas","Balak","Pinchas","Matos","Masei",
    "Devarim","Va'eschanan","Eikev","Re'eh","Shoftim","Ki Seitzei","Ki Savo","Nitzavim","Vayeilech","Haazinu","Vezos Haberachah"
  ];

  const parshaOrderIndex = new Map(PARSHA_ORDER.map((p,i)=>[normalizeParshaKey(p), i]));

  const elStatus = document.getElementById("status");
  const parshaListEl = document.getElementById("parshaList");
  const halachaListEl = document.getElementById("halachaList");
  const parshaCountEl = document.getElementById("parshaCount");
  const halachaCountEl = document.getElementById("halachaCount");

  const parshaCard = document.getElementById("parshaCard");
  const halachaCard = document.getElementById("halachaCard");
  const tabAll = document.getElementById("tabAll");
  const tabParsha = document.getElementById("tabParsha");
  const tabHalacha = document.getElementById("tabHalacha");

  function setTab(which){
    const isAll = which === "all";
    const isParsha = which === "parsha";
    const isHalacha = which === "halacha";
    tabAll.setAttribute("aria-pressed", String(isAll));
    tabParsha.setAttribute("aria-pressed", String(isParsha));
    tabHalacha.setAttribute("aria-pressed", String(isHalacha));
    parshaCard.style.display = (isAll || isParsha) ? "block" : "none";
    halachaCard.style.display = (isAll || isHalacha) ? "block" : "none";
  }
  tabAll.addEventListener("click", ()=>setTab("all"));
  tabParsha.addEventListener("click", ()=>setTab("parsha"));
  tabHalacha.addEventListener("click", ()=>setTab("halacha"));

function rowItem({title, meta, url, badgeText, durText}){
  const row = document.createElement("div");
  row.className = "row";
  row.setAttribute("role", "button");
  row.setAttribute("tabindex", "0");

  const left = document.createElement("div");
  left.className = "left";

  const t = document.createElement("div");
  t.className = "title";
  t.textContent = title || "Untitled";

  const m = document.createElement("div");
  m.className = "meta";
  m.textContent = meta || "";

  left.appendChild(t);
  left.appendChild(m);

  const right = document.createElement("div");
  right.className = "right";

  if (durText){
    const dur = document.createElement("div");
    dur.className = "badge badgeDur";
    dur.textContent = durText;
    right.appendChild(dur);
  }

  const badge = document.createElement("div");
  badge.className = "badge badgeLong";
  badge.textContent = badgeText || "";
  right.appendChild(badge);

  // Optional: keep an "open" link without breaking inline play
  const open = document.createElement("a");
  open.className = "openLink";
  open.href = url;
  open.target = "_blank";
  open.rel = "noopener";
  open.textContent = "↗";
  open.title = "Open in new tab";
  right.appendChild(open);

  const controls = document.createElement("div");
controls.className = "controls";
controls.innerHTML = `
  <div class="speedBtns">
    ${[1,1.25,1.5,2].map(r => `<button type="button" data-rate="${r}">${r}×</button>`).join("")}
  </div>
`;
  
  const audioWrap = document.createElement("div");
  audioWrap.className = "audioWrap";
  audioWrap.innerHTML = `
    <audio controls preload="none">
      <source src="${String(url).replace(/"/g, "&quot;")}" type="audio/mpeg">
    </audio>
  `;

  row.appendChild(left);
  row.appendChild(right);
  row.appendChild(controls);
  row.appendChild(audioWrap);

  // --- behavior ---
  const audio = audioWrap.querySelector("audio");
  // default rate (optional: remember like one-minute)
let currentRate = 1;
audio.playbackRate = currentRate;

controls.querySelectorAll('button[data-rate]').forEach(btn => {
  btn.addEventListener("click", (e) => {
    e.stopPropagation();
    const r = Number(btn.dataset.rate);
    if (Number.isFinite(r)) {
      audio.playbackRate = r;
      currentRate = r;
      controls.querySelectorAll("button").forEach(b => b.classList.toggle("active", b === btn));
    }
  });
});

// show controls when playing
audio.addEventListener("play", () => {
  closeOthers();
  row.classList.add("isOpen");     // this will reveal speed buttons too
});
  function closeOthers(){
    document.querySelectorAll(".row.isOpen").forEach(r => {
      if (r !== row) {
        r.classList.remove("isOpen");
        const a = r.querySelector("audio");
        if (a && !a.paused) { a.pause(); }
      }
    });
  }

  function toggleOpen(play){
    const willOpen = !row.classList.contains("isOpen");
    if (willOpen){
      closeOthers();
      row.classList.add("isOpen");
      if (play) audio.play().catch(()=>{});
    } else {
      row.classList.remove("isOpen");
      if (!audio.paused) audio.pause();
    }
  }

  // click anywhere toggles, but don't hijack clicks on the open link or audio controls
  row.addEventListener("click", (e) => {
    if (e.target.closest("a.openLink") || e.target.closest("audio") || e.target.closest(".speedBtns")) return;
    toggleOpen(true);
  });

  row.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      toggleOpen(true);
    }
  });

  audio.addEventListener("play", () => {
    closeOthers();
    row.classList.add("isOpen");
  });

  return row;
}

  // ---------- duration helpers ----------
  function fmtHMS(sec){
    sec = Math.round(sec);
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = sec % 60;
    const mm = String(m).padStart(h ? 2 : 1, "0");
    const ss = String(s).padStart(2, "0");
    return h ? `${h}:${mm}:${ss}` : `${m}:${ss}`;
  }

  function parseHMS(str){
    const parts = String(str || "").trim().split(":").map(Number);
    if (parts.some(n => !Number.isFinite(n))) return NaN;
    if (parts.length === 2) return parts[0] * 60 + parts[1];
    if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
    return NaN;
  }

  function normalizeParshaKey(s){
    return String(s || "")
      .toLowerCase()
      .replace(/[\u2019']/g, "")   // apostrophes
      .replace(/\s+/g, "")        // spaces
      .replace(/-/g, "");         // dashes
  }

  // ---------- Robust extraction helpers ----------
  function extractConstBlock(source, constName){
    const re = new RegExp(`const\\s+${constName}\\s*=`, "m");
    const m = source.match(re);
    if (!m) return null;

    const start = m.index + m[0].length;
    let i = start;
    let depthObj = 0, depthArr = 0;
    let inStr = null;
    let escape = false;

    for (; i < source.length; i++){
      const ch = source[i];

      if (inStr){
        if (escape){ escape = false; continue; }
        if (ch === "\\"){ escape = true; continue; }
        if (ch === inStr){ inStr = null; continue; }
        continue;
      }

      if (ch === '"' || ch === "'" || ch === "`"){ inStr = ch; continue; }
      if (ch === "{") depthObj++;
      else if (ch === "}") depthObj--;
      else if (ch === "[") depthArr++;
      else if (ch === "]") depthArr--;
      else if (ch === ";" && depthObj === 0 && depthArr === 0){
        return source.slice(start, i).trim();
      }
    }
    return null;
  }

  function evalAsData(expr){
    return Function(`"use strict"; return (${expr});`)();
  }

  // ---------- parse / flatten ----------
  function parseParshaInDepth(obj){
    const rows = [];
    for (const [parshaName, arr] of Object.entries(obj || {})){
      for (const it of (arr || [])){
        const durText = it.duration || "";
        const durSec = parseHMS(durText);
        const key = normalizeParshaKey(parshaName);
        rows.push({
          title: it.label || "Untitled",
          url: it.url,
          parsha: parshaName,
          parshaKey: key,
          parshaIdx: parshaOrderIndex.has(key) ? parshaOrderIndex.get(key) : 9999,
          durText,
          durSec
        });
      }
    }
    return rows;
  }

  function flattenHalachaAudios(PAGE_DATA){
    const out = [];
    for (const cat of (PAGE_DATA || [])){
      const catName = cat.category || "Halacha";

      // subcategories
      const subs = cat.subcategories || [];
      for (const sub of subs){
        const subName = sub.name || "";
        const items = sub.items || [];
        for (const it of items){
          if (!it || it.type !== "audio" || !it.url) continue;
          out.push({
            title: it.title || "Untitled",
            url: it.url,
            note: it.note || "",
            cat: catName,
            sub: subName
          });
        }
      }

      // direct items (some cats)
      const directItems = cat.items || [];
      for (const it of directItems){
        if (!it || it.type !== "audio" || !it.url) continue;
        out.push({
          title: it.title || "Untitled",
          url: it.url,
          note: it.note || "",
          cat: catName,
          sub: ""
        });
      }
    }
    return out;
  }

function getAudioDurationSec(url){
  const CACHE_KEY = "TM_AUDIO_DUR_CACHE_v1";

  let cache;
  try {
    cache = JSON.parse(localStorage.getItem(CACHE_KEY) || "{}");
  } catch {
    cache = {};
  }

  if (cache[url] && Number.isFinite(cache[url])) {
    return Promise.resolve(cache[url]);
  }

  return new Promise((resolve) => {
    const audio = new Audio();
    audio.preload = "metadata";
    audio.src = url;

    const done = (sec) => {
      audio.removeEventListener("loadedmetadata", onMeta);
      audio.removeEventListener("error", onErr);

      if (Number.isFinite(sec)) {
        cache[url] = sec;
        try {
          localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
        } catch {}
      }

      resolve(sec);
    };

    const onMeta = () => done(isFinite(audio.duration) ? audio.duration : NaN);
    const onErr = () => done(NaN);

    audio.addEventListener("loadedmetadata", onMeta, { once: true });
    audio.addEventListener("error", onErr, { once: true });
  });
}


  async function loadData(){
    elStatus.textContent = "Fetching sources…";
    const [parshaSrc, halachaSrc] = await Promise.all([
      fetch("./parsha.html", { cache: "no-store" }).then(r => r.text()),
      fetch("./halacha.html", { cache: "no-store" }).then(r => r.text()),
    ]);

    const parshaExpr = extractConstBlock(parshaSrc, "PARSHA_INDEPTH");
    const halachaExpr = extractConstBlock(halachaSrc, "PAGE_DATA");

    if (!parshaExpr) throw new Error("Could not find const PARSHA_INDEPTH in parsha.html");
    if (!halachaExpr) throw new Error("Could not find const PAGE_DATA in halacha.html");

    const PARSHA_INDEPTH = evalAsData(parshaExpr);
    const PAGE_DATA = evalAsData(halachaExpr);

    return { PARSHA_INDEPTH, PAGE_DATA };
  }

  async function main(){
    const { PARSHA_INDEPTH, PAGE_DATA } = await loadData();

    // ---------- Parsha render (Parsha order) ----------
    parshaListEl.innerHTML = "";
    let parshaRows = parseParshaInDepth(PARSHA_INDEPTH);

    // Sort: Parsha order, then label
    parshaRows.sort((a,b) => {
      if (a.parshaIdx !== b.parshaIdx) return a.parshaIdx - b.parshaIdx;
      return String(a.title).localeCompare(String(b.title));
    });

    parshaCountEl.textContent = parshaRows.length ? `${parshaRows.length} items` : "";

    if (!parshaRows.length){
      parshaListEl.innerHTML = `<div class="muted">No Parsha in-depth items found.</div>`;
    } else {
      for (const r of parshaRows){
        parshaListEl.appendChild(rowItem({
          title: r.title,
          meta: r.parsha,
          url: r.url,
          durText: r.durText || "",
          badgeText: "Parsha"
        }));
      }
    }

    // ---------- Halacha render (Long only; sort Cat → Sub → Title) ----------
    halachaListEl.innerHTML = "";
    const halachaAudios = flattenHalachaAudios(PAGE_DATA);

    if (!halachaAudios.length){
      halachaListEl.innerHTML = `<div class="muted">No Halacha audio items found.</div>`;
      halachaCountEl.textContent = "";
      elStatus.textContent = "Ready";
      return;
    }

    elStatus.textContent = "Scanning durations…";
    const longOnes = [];

    for (let i=0; i<halachaAudios.length; i++){
      const it = halachaAudios[i];
      const sec = await getAudioDurationSec(it.url);
      if (isFinite(sec) && sec >= LONG_SEC){
        longOnes.push({
          ...it,
          durSec: sec,
          durText: fmtHMS(sec)
        });
      }
      if (i % 10 === 0){
        halachaCountEl.textContent = `Scanning… found ${longOnes.length} long so far`;
      }
    }

    function parseMDY(dateStr){
  // expecting M/D/YYYY
  if (!dateStr) return 0;
  const parts = String(dateStr).trim().split("/");
  if (parts.length !== 3) return 0;
  const [m,d,y] = parts.map(Number);
  if (!m || !d || !y) return 0;
  return new Date(y, m-1, d).getTime();
}

// Sort: Newest first (date desc)
longOnes.sort((a,b) => {
  return parseMDY(b.note) - parseMDY(a.note);
});


    halachaCountEl.textContent = longOnes.length ? `${longOnes.length} items` : "";

    if (!longOnes.length){
      halachaListEl.innerHTML = `<div class="muted">No Halacha items reached 10+ minutes.</div>`;
    } else {
      for (const it of longOnes){
        const meta = [it.note, it.cat, it.sub].filter(Boolean).join(" • ");
        halachaListEl.appendChild(rowItem({
          title: it.title,
          meta,
          url: it.url,
          durText: it.durText || "",
          badgeText: "Long"
        }));
      }
    }

    elStatus.textContent = "Ready";
  }

  main().catch((e)=>{
    console.error(e);
    elStatus.textContent = "Error";
    parshaListEl.innerHTML = `<div class="muted">Error: ${String(e.message || e)}</div>`;
    halachaListEl.innerHTML = `<div class="muted">Check console for details.</div>`;
  });
</script>

<script>
(function(){
  const links = document.querySelectorAll(".tm-topbar a[href]:not(.home-link)");
  const raw = (location.pathname || "/").replace(/\/+$/, "") || "/";
  const current = (raw === "/index.html") ? "/" : raw;

  links.forEach(a => {
    const u = new URL(a.getAttribute("href"), location.href);
    const lpRaw = (u.pathname || "/").replace(/\/+$/, "") || "/";
    const lp = (lpRaw === "/index.html") ? "/" : lpRaw;

    if (lp === current) a.classList.add("active");
  });
})();
</script>

  <script>
(function(){

  const sections = [
    { toggle: 0, content: "parshaContent" },
    { toggle: 1, content: "halachaContent" }
  ];

  const toggles = document.querySelectorAll(".sectionToggle");

  sections.forEach((s, i) => {
    const toggle = toggles[i];
    const content = document.getElementById(s.content);
    const chevron = toggle.querySelector(".sectionChevron");

    if (!toggle || !content) return;

    // start expanded
    content.classList.add("expanded");

    toggle.addEventListener("click", () => {
      const isExpanded = content.classList.contains("expanded");

      content.classList.toggle("expanded", !isExpanded);
      content.classList.toggle("collapsed", isExpanded);
      chevron.classList.toggle("rotated", !isExpanded);
    });
  });

})();
</script>

  
</body>
</html>
