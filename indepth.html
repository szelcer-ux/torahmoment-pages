<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TorahMoment — In-Depth Shiurim</title>

  <style>
    :root{
      --bg:#f7f7f8;
      --card:#ffffff;
      --text:#111;
      --muted:#666;
      --border:#e7e7ee;
      --accent:#0d9488;
      --shadow:0 6px 22px rgba(0,0,0,0.07);
      --radius:16px;
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:1060px;margin:0 auto;padding:22px;}
    .top{display:flex;justify-content:space-between;align-items:flex-end;gap:16px;flex-wrap:wrap;}
    h1{margin:0;font-size:28px;letter-spacing:-0.02em;}
    .sub{color:var(--muted);margin-top:6px;font-size:14px;}

    .pillbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:16px;}
    .pill{border:1px solid var(--border);background:#fff;border-radius:999px;padding:8px 12px;font-size:14px;cursor:pointer;}
    .pill[aria-pressed="true"]{border-color:rgba(13,148,136,.35);box-shadow:0 2px 10px rgba(0,0,0,0.05);}

    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px;margin-top:14px;}
    .sectionTitle{display:flex;align-items:baseline;gap:10px;flex-wrap:wrap;}
    .sectionTitle h2{margin:0;font-size:18px;}
    .count{color:var(--muted);font-size:13px;}

    .list{margin-top:10px;display:flex;flex-direction:column;gap:8px;}
    .row{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:12px;border:1px solid var(--border);border-radius:14px;background:#fff;
      text-decoration:none;color:inherit;
    }
    .row:hover{transform:translateY(-1px);}
    .left{min-width:0;flex:1;}
    .title{font-weight:750;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .meta{margin-top:3px;color:var(--muted);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

    .right{display:flex;align-items:center;gap:8px;flex:0 0 auto;}
    .badge{font-size:12px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:#fff;}
    .badgeLong{border-color:rgba(13,148,136,.35);}
    .badgeDur{color:var(--muted);}

    .muted{color:var(--muted);}

    .loader{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:14px;}
    .dot{width:8px;height:8px;border-radius:50%;background:var(--muted);opacity:.35;animation:pulse 1.2s infinite;}
    .dot:nth-child(2){animation-delay:.2s}
    .dot:nth-child(3){animation-delay:.4s}
    @keyframes pulse{0%,100%{opacity:.25}50%{opacity:.7}}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>In-Depth Shiurim</h1>
        <div class="sub">One place for the more serious / developed TorahMoment shiurim.</div>
      </div>
      <div class="muted" id="status">Loading…</div>
    </div>

    <div class="pillbar">
      <button class="pill" id="tabAll" aria-pressed="true" type="button">All</button>
      <button class="pill" id="tabParsha" aria-pressed="false" type="button">Parsha In-Depth</button>
      <button class="pill" id="tabHalacha" aria-pressed="false" type="button">Halacha (10+ min)</button>
    </div>

    <div class="card" id="parshaCard">
      <div class="sectionTitle">
        <h2>Parsha In-Depth</h2>
        <div class="count" id="parshaCount"></div>
      </div>
      <div class="list" id="parshaList">
        <div class="loader"><span class="dot"></span><span class="dot"></span><span class="dot"></span> Loading Parsha in-depth…</div>
      </div>
    </div>

    <div class="card" id="halachaCard">
      <div class="sectionTitle">
        <h2>Halacha / Hashkafa — Long Shiurim</h2>
        <div class="count" id="halachaCount"></div>
      </div>
      <div class="list" id="halachaList">
        <div class="loader"><span class="dot"></span><span class="dot"></span><span class="dot"></span> Loading Halacha data…</div>
      </div>
      <div class="sub" style="margin-top:10px;">Long = 10 minutes or more (based on audio metadata).</div>
    </div>
  </div>

<script>
  const LONG_SEC = 600;

  // Parsha order (full Torah order)
  const PARSHA_ORDER = [
    "Bereishis","Noach","Lech Lecha","Vayeira","Chayei Sarah","Toldos","Vayeitzei","Vayishlach","Vayeishev","Miketz","Vayigash","Vayechi",
    "Shemos","Va'eira","Bo","Beshalach","Yisro","Mishpatim","Terumah","Tetzaveh","Ki Sisa","Vayakhel","Pekudei",
    "Vayikra","Tzav","Shemini","Tazria","Metzora","Achrei Mos","Kedoshim","Emor","Behar","Bechukosai",
    "Bamidbar","Naso","Beha'aloscha","Shelach","Korach","Chukas","Balak","Pinchas","Matos","Masei",
    "Devarim","Va'eschanan","Eikev","Re'eh","Shoftim","Ki Seitzei","Ki Savo","Nitzavim","Vayeilech","Haazinu","Vezos Haberachah"
  ];

  const parshaOrderIndex = new Map(PARSHA_ORDER.map((p,i)=>[normalizeParshaKey(p), i]));

  const elStatus = document.getElementById("status");
  const parshaListEl = document.getElementById("parshaList");
  const halachaListEl = document.getElementById("halachaList");
  const parshaCountEl = document.getElementById("parshaCount");
  const halachaCountEl = document.getElementById("halachaCount");

  const parshaCard = document.getElementById("parshaCard");
  const halachaCard = document.getElementById("halachaCard");
  const tabAll = document.getElementById("tabAll");
  const tabParsha = document.getElementById("tabParsha");
  const tabHalacha = document.getElementById("tabHalacha");

  function setTab(which){
    const isAll = which === "all";
    const isParsha = which === "parsha";
    const isHalacha = which === "halacha";
    tabAll.setAttribute("aria-pressed", String(isAll));
    tabParsha.setAttribute("aria-pressed", String(isParsha));
    tabHalacha.setAttribute("aria-pressed", String(isHalacha));
    parshaCard.style.display = (isAll || isParsha) ? "block" : "none";
    halachaCard.style.display = (isAll || isHalacha) ? "block" : "none";
  }
  tabAll.addEventListener("click", ()=>setTab("all"));
  tabParsha.addEventListener("click", ()=>setTab("parsha"));
  tabHalacha.addEventListener("click", ()=>setTab("halacha"));

  function rowLink({title, meta, url, badgeText, durText}){
    const a = document.createElement("a");
    a.className = "row";
    a.href = url;
    a.target = "_blank";
    a.rel = "noopener";

    const left = document.createElement("div");
    left.className = "left";

    const t = document.createElement("div");
    t.className = "title";
    t.textContent = title || "Untitled";

    const m = document.createElement("div");
    m.className = "meta";
    m.textContent = meta || "";

    left.appendChild(t);
    left.appendChild(m);

    const right = document.createElement("div");
    right.className = "right";

    if (durText){
      const dur = document.createElement("div");
      dur.className = "badge badgeDur";
      dur.textContent = durText;
      right.appendChild(dur);
    }

    const badge = document.createElement("div");
    badge.className = "badge badgeLong";
    badge.textContent = badgeText || "";
    right.appendChild(badge);

    a.appendChild(left);
    a.appendChild(right);
    return a;
  }

  // ---------- duration helpers ----------
  function fmtHMS(sec){
    sec = Math.round(sec);
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600) / 60);
    const s = sec % 60;
    const mm = String(m).padStart(h ? 2 : 1, "0");
    const ss = String(s).padStart(2, "0");
    return h ? `${h}:${mm}:${ss}` : `${m}:${ss}`;
  }

  function parseHMS(str){
    const parts = String(str || "").trim().split(":").map(Number);
    if (parts.some(n => !Number.isFinite(n))) return NaN;
    if (parts.length === 2) return parts[0] * 60 + parts[1];
    if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
    return NaN;
  }

  function normalizeParshaKey(s){
    return String(s || "")
      .toLowerCase()
      .replace(/[\u2019']/g, "")   // apostrophes
      .replace(/\s+/g, "")        // spaces
      .replace(/-/g, "");         // dashes
  }

  // ---------- Robust extraction helpers ----------
  function extractConstBlock(source, constName){
    const re = new RegExp(`const\\s+${constName}\\s*=`, "m");
    const m = source.match(re);
    if (!m) return null;

    const start = m.index + m[0].length;
    let i = start;
    let depthObj = 0, depthArr = 0;
    let inStr = null;
    let escape = false;

    for (; i < source.length; i++){
      const ch = source[i];

      if (inStr){
        if (escape){ escape = false; continue; }
        if (ch === "\\"){ escape = true; continue; }
        if (ch === inStr){ inStr = null; continue; }
        continue;
      }

      if (ch === '"' || ch === "'" || ch === "`"){ inStr = ch; continue; }
      if (ch === "{") depthObj++;
      else if (ch === "}") depthObj--;
      else if (ch === "[") depthArr++;
      else if (ch === "]") depthArr--;
      else if (ch === ";" && depthObj === 0 && depthArr === 0){
        return source.slice(start, i).trim();
      }
    }
    return null;
  }

  function evalAsData(expr){
    return Function(`"use strict"; return (${expr});`)();
  }

  // ---------- parse / flatten ----------
  function parseParshaInDepth(obj){
    const rows = [];
    for (const [parshaName, arr] of Object.entries(obj || {})){
      for (const it of (arr || [])){
        const durText = it.duration || "";
        const durSec = parseHMS(durText);
        const key = normalizeParshaKey(parshaName);
        rows.push({
          title: it.label || "Untitled",
          url: it.url,
          parsha: parshaName,
          parshaKey: key,
          parshaIdx: parshaOrderIndex.has(key) ? parshaOrderIndex.get(key) : 9999,
          durText,
          durSec
        });
      }
    }
    return rows;
  }

  function flattenHalachaAudios(PAGE_DATA){
    const out = [];
    for (const cat of (PAGE_DATA || [])){
      const catName = cat.category || "Halacha";

      // subcategories
      const subs = cat.subcategories || [];
      for (const sub of subs){
        const subName = sub.name || "";
        const items = sub.items || [];
        for (const it of items){
          if (!it || it.type !== "audio" || !it.url) continue;
          out.push({
            title: it.title || "Untitled",
            url: it.url,
            note: it.note || "",
            cat: catName,
            sub: subName
          });
        }
      }

      // direct items (some cats)
      const directItems = cat.items || [];
      for (const it of directItems){
        if (!it || it.type !== "audio" || !it.url) continue;
        out.push({
          title: it.title || "Untitled",
          url: it.url,
          note: it.note || "",
          cat: catName,
          sub: ""
        });
      }
    }
    return out;
  }

  function getAudioDurationSec(url){
    return new Promise((resolve) => {
      const audio = new Audio();
      audio.preload = "metadata";
      audio.src = url;

      const done = (sec) => {
        audio.removeEventListener("loadedmetadata", onMeta);
        audio.removeEventListener("error", onErr);
        resolve(sec);
      };

      const onMeta = () => done(isFinite(audio.duration) ? audio.duration : NaN);
      const onErr = () => done(NaN);

      audio.addEventListener("loadedmetadata", onMeta, { once: true });
      audio.addEventListener("error", onErr, { once: true });
    });
  }

  async function loadData(){
    elStatus.textContent = "Fetching sources…";
    const [parshaSrc, halachaSrc] = await Promise.all([
      fetch("./parsha.html", { cache: "no-store" }).then(r => r.text()),
      fetch("./halacha.html", { cache: "no-store" }).then(r => r.text()),
    ]);

    const parshaExpr = extractConstBlock(parshaSrc, "PARSHA_INDEPTH");
    const halachaExpr = extractConstBlock(halachaSrc, "PAGE_DATA");

    if (!parshaExpr) throw new Error("Could not find const PARSHA_INDEPTH in parsha.html");
    if (!halachaExpr) throw new Error("Could not find const PAGE_DATA in halacha.html");

    const PARSHA_INDEPTH = evalAsData(parshaExpr);
    const PAGE_DATA = evalAsData(halachaExpr);

    return { PARSHA_INDEPTH, PAGE_DATA };
  }

  async function main(){
    const { PARSHA_INDEPTH, PAGE_DATA } = await loadData();

    // ---------- Parsha render (Parsha order) ----------
    parshaListEl.innerHTML = "";
    let parshaRows = parseParshaInDepth(PARSHA_INDEPTH);

    // Sort: Parsha order, then label
    parshaRows.sort((a,b) => {
      if (a.parshaIdx !== b.parshaIdx) return a.parshaIdx - b.parshaIdx;
      return String(a.title).localeCompare(String(b.title));
    });

    parshaCountEl.textContent = parshaRows.length ? `${parshaRows.length} items` : "";

    if (!parshaRows.length){
      parshaListEl.innerHTML = `<div class="muted">No Parsha in-depth items found.</div>`;
    } else {
      for (const r of parshaRows){
        parshaListEl.appendChild(rowLink({
          title: r.title,
          meta: r.parsha,
          url: r.url,
          durText: r.durText || "",
          badgeText: "Parsha"
        }));
      }
    }

    // ---------- Halacha render (Long only; sort Cat → Sub → Title) ----------
    halachaListEl.innerHTML = "";
    const halachaAudios = flattenHalachaAudios(PAGE_DATA);

    if (!halachaAudios.length){
      halachaListEl.innerHTML = `<div class="muted">No Halacha audio items found.</div>`;
      halachaCountEl.textContent = "";
      elStatus.textContent = "Ready";
      return;
    }

    elStatus.textContent = "Scanning durations…";
    const longOnes = [];

    for (let i=0; i<halachaAudios.length; i++){
      const it = halachaAudios[i];
      const sec = await getAudioDurationSec(it.url);
      if (isFinite(sec) && sec >= LONG_SEC){
        longOnes.push({
          ...it,
          durSec: sec,
          durText: fmtHMS(sec)
        });
      }
      if (i % 10 === 0){
        halachaCountEl.textContent = `Scanning… found ${longOnes.length} long so far`;
      }
    }

    // Sort: Category → Subcategory → Title
    longOnes.sort((a,b) => {
      const ac = String(a.cat||"").localeCompare(String(b.cat||""));
      if (ac) return ac;
      const as = String(a.sub||"").localeCompare(String(b.sub||""));
      if (as) return as;
      return String(a.title||"").localeCompare(String(b.title||""));
    });

    halachaCountEl.textContent = longOnes.length ? `${longOnes.length} items` : "";

    if (!longOnes.length){
      halachaListEl.innerHTML = `<div class="muted">No Halacha items reached 10+ minutes.</div>`;
    } else {
      for (const it of longOnes){
        const meta = [it.cat, it.sub, it.note].filter(Boolean).join(" • ");
        halachaListEl.appendChild(rowLink({
          title: it.title,
          meta,
          url: it.url,
          durText: it.durText || "",
          badgeText: "Long"
        }));
      }
    }

    elStatus.textContent = "Ready";
  }

  main().catch((e)=>{
    console.error(e);
    elStatus.textContent = "Error";
    parshaListEl.innerHTML = `<div class="muted">Error: ${String(e.message || e)}</div>`;
    halachaListEl.innerHTML = `<div class="muted">Check console for details.</div>`;
  });
</script>
</body>
</html>
