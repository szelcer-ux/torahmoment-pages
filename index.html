<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Parsha Divrei Torah</title>
  <style>
    :root { --radius: 14px; --shadow: 0 10px 28px rgba(0,0,0,.08); }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:#f6f7fb; color:#111827; }
    header { position: sticky; top: 0; z-index: 10; background: rgba(246,247,251,.92); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(17,24,39,.08); }
    .wrap { max-width: 1150px; margin: 0 auto; padding: 14px 16px; }
    h1 { margin: 0; font-size: 24px; letter-spacing: -.02em; }
    .sub { margin: 6px 0 0; color:#6b7280; font-size: 14px; }

    .controls { display:grid; grid-template-columns: 1fr 220px 220px 140px; gap:10px; margin-top:14px; }
    input, select, button { width:100%; border:1px solid rgba(17,24,39,.12); border-radius:12px; padding:10px 12px; font-size:14px; background:#fff; }
    button { cursor:pointer; background:#111827; color:#fff; }
    button:hover { filter: brightness(1.05); }
    @media (max-width: 900px){ .controls{ grid-template-columns: 1fr 1fr; } }
    @media (max-width: 600px){ .controls{ grid-template-columns: 1fr; } }

    main { padding: 18px 0 40px; }
    .bar { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:12px; color:#6b7280; font-size:13px; }
    .grid { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 620px){ .grid{ grid-template-columns: 1fr; } }

    .card { background:#fff; border:1px solid rgba(17,24,39,.08); border-radius: var(--radius); overflow:hidden; box-shadow: var(--shadow); transition: transform .12s ease, box-shadow .12s ease; text-decoration:none; color:inherit; }
    .card:hover { transform: translateY(-2px); box-shadow: 0 14px 34px rgba(0,0,0,.10); }
    .thumb { display:block; width:100%; aspect-ratio: 16/9; background:#e5e7eb; position:relative; overflow:hidden; }
    .thumb img { width:100%; height:100%; object-fit:cover; display:block; }
    .play { position:absolute; inset:0; display:grid; place-items:center; background: linear-gradient(to top, rgba(0,0,0,.45), rgba(0,0,0,0)); opacity:.95; }
    .play svg { width:62px; height:62px; filter: drop-shadow(0 6px 10px rgba(0,0,0,.35)); }

    .meta { padding:12px 12px 14px; }
    .meta h3 { margin:0 0 6px; font-size:16px; line-height:1.25; }
    .meta .date { margin:0; color:#6b7280; font-size:13px; }
    .meta .desc { margin:8px 0 0; color:#6b7280; font-size:13px; line-height:1.35; }
    .pillrow { margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
    .pill { display:inline-block; font-size:12px; padding:6px 9px; border-radius:999px; background:#f3f4f6; border:1px solid rgba(17,24,39,.08); color:#111827; }

    .empty, .notice { background:#fff; border-radius: var(--radius); padding:16px; color:#6b7280; text-align:center; }
    .empty { border:1px dashed rgba(17,24,39,.25); }
    .notice { border:1px solid rgba(17,24,39,.10); margin-bottom:12px; }
    .small { font-size:12px; color:#6b7280; }
    code { background:#f3f4f6; padding:2px 6px; border-radius:8px; }
	
	.linksBox{
  background:#fff;
  border:1px solid rgba(17,24,39,.08);
  border-radius:14px;
  padding:14px;
  margin: 0 0 14px;
  box-shadow: 0 10px 28px rgba(0,0,0,.06);
}
.linksTop{
  display:flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}
.linksTitle{
  font-weight: 700;
  font-size: 15px;
}
.linksHint{
  color:#6b7280;
  font-size: 12px;
}




 

.audioIcon{
  font-size:16px;
  opacity:0.75;
}



 .linksList{
  display:flex;
  flex-direction: column;
  gap: 0;                 /* dividers handle spacing */
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid rgba(17,24,39,.10);
  background: #fff;
}

/* Each row */
.audioLink{
  display:flex;
  align-items:center;
  gap:12px;
  padding:12px 12px;
  text-decoration:none;
  color:#111827;
  font-size:14px;
  background:#fff;
  transition: background .12s ease, transform .08s ease;
}

/* Subtle divider between rows */
.audioLink + .audioLink{
  border-top: 1px solid rgba(17,24,39,.08);
}

/* Hover/focus = ‚Äúmedia player‚Äù feel */
.audioLink:hover{
  background:#f9fafb;
}
.audioLink:active{
  transform: translateY(1px);
}
.audioLink:focus-visible{
  outline: 2px solid rgba(17,24,39,.25);
  outline-offset: -2px;
}

/* Play button in a circle */
.playBtn{
  width: 34px;
  height: 34px;
  border-radius: 999px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#f3f4f6;
  border: 1px solid rgba(17,24,39,.10);
  flex: 0 0 auto;
}

.playIcon{
  width: 0;
  height: 0;
  border-left: 9px solid #111827;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  opacity: 0.75;
  margin-left: 2px; /* optical centering inside circle */
}

/* Title text */
.audioTitle{
  min-width: 0;               /* enables ellipsis */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Right-side meta: duration + badge */
.audioMeta{
  margin-left: auto;
  display:flex;
  align-items:center;
  gap:8px;
  font-size:12px;
  color:#6b7280;
  flex: 0 0 auto;
}

.audioBadge{
  padding:3px 8px;
  border-radius:999px;
  border:1px solid rgba(17,24,39,.15);
  background:#f3f4f6;
  font-size:11px;
  color:#111827;
  white-space: nowrap;
}



.linksBox {
  margin-top: 24px;
}

/* Mobile: prevent the header from taking over the screen (esp inside Google Sites embeds) */

/* Filters button (hidden on desktop) */
.filtersBtn{
  display:none;
  border:1px solid rgba(17,24,39,.12);
  border-radius: 12px;
  padding:10px 12px;
  font-size:14px;
  background:#fff;
  cursor:pointer;
  text-align:left;
}

@media (max-width: 780px){

  /* Turn off sticky header on mobile */
  header{
    position: static;
    backdrop-filter: none;
  }

  /* Tighten spacing */
  .wrap{
    padding: 10px 10px;
  }

  h1{
    font-size: 18px;
    line-height: 1.2;
  }

  .sub{
    margin-top: 4px;
    font-size: 12px;
  }

  /* Controls: stack + reduce padding */
  .controls{
    grid-template-columns: 1fr;
    gap: 8px;
    margin-top: 10px;
  }

  input, select, button{
    padding: 9px 10px;
    font-size: 14px;
    border-radius: 10px;
  }

/* Mobile behavior */
@media (max-width: 780px){
  .filtersBtn{ display:block; margin-top:10px; }
  
 /* collapsed by default */
  .controls{
    display:none;
    margin-top:10px;
    grid-template-columns: 1fr; /* in case you use grid */
    gap:8px;
  }

  /* when expanded */
  .controls.is-open{
    display:grid;
  } 

/* Hide status/debug info on mobile */
@media (max-width: 780px){
  .notice{
    display: none;
  }
}

/* Header row: title + filters */
.headerRow{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

/* Filters button: default (desktop) stays hidden as before */
.filtersBtn{
  display: none;
}

/* Mobile-only adjustments */
@media (max-width: 780px){
  .filtersBtn{
    display: inline-flex;
    align-items: center;
    gap: 4px;

    width: auto;              /* ‚úÖ override old width:100% */
    max-width: none;          /* ‚úÖ safety */
    
    padding: 4px 8px;
    font-size: 12px;
    line-height: 1;
    font-weight: 600;

    border-radius: 999px;
    border: 1px solid rgba(17,24,39,.18);
    background: #f9fafb;
    color: #111827;

    cursor: pointer;
    white-space: nowrap;
  }
}




  /* Make sure title doesn‚Äôt wrap awkwardly */
  #pageH1{
    font-size: 18px;
    margin: 0;
  }
}

@media (max-width: 780px){
  .filtersBtn{
    width: fit-content !important;   /* üî• kills width:100% */
    flex: 0 0 auto !important;        /* üî• prevents flex stretching */
  }
}


  /* Optional: reduce the notice box padding if you have it */
  .notice{
    padding: 12px;
  }
}

	
  </style>
</head>
<body>
<header>
  <div class="wrap">
<div class="headerRow">
  <h1 id="pageH1">Parsha Divrei Torah</h1>

  <button id="filtersBtn" class="filtersBtn" type="button"
          aria-expanded="false" aria-controls="controlsWrap">
    Filters
  </button>
</div>


    <div class="controls" id="controlsWrap">
      <input id="q" type="search" placeholder="Search within Parsha videos..." />
      <select id="parsha">
        <option value="">All Parshios</option>
      </select>
      <select id="sort">
        <option value="new">Newest first</option>
        <option value="old">Oldest first</option>
        <option value="title">Title A‚ÄìZ</option>
      </select>
      <button id="clear">Clear</button>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="notice">
    <div><strong>Status:</strong> <span id="statusText">Ready</span></div>
    <div class="small" id="statusSmall"></div>
  </div>

  <div class="bar">
    <div id="count"></div>
   
  </div>
 
  <div id="grid" class="grid"></div>

 
<div id="linksBox" class="linksBox" style="display:none;">
  <div class="linksTop">
    <div class="linksTitle" id="linksTitle">Links</div>
    <div class="linksHint" id="linksHint"></div>
  </div>
  <div id="linksList" class="linksList"></div>
</div> 

 <div id="empty" class="empty" style="display:none;">No videos match your filters.</div>
</main>

<script>
  // =============================
  // CONFIG ‚Äî EDIT THIS
  // =============================
  const API_KEY    = "AIzaSyDbJnY2cPtyyVya7YNzxG0hCju7ikBUWsU";
  const CHANNEL_ID = "UCzx1pweEHKhsIfPkQZbRH4w";
  const MAX_TO_FETCH = 5000;

 const filtersBtn = document.getElementById("filtersBtn");
const controlsWrap = document.getElementById("controlsWrap");



  // Your descriptions include: "Dvar Torah Parshas Noach - Living mercifully"
  const PARSHA_DESC_NEEDLE = "dvar torah parshas";

  // Extract the Parsha name from the description.
  // Captures up to the first " - " (or end of line)
  // Examples:
  // "Dvar Torah Parshas Noach - Living mercifully" -> "Noach"
  // "Dvar Torah Parshas Vayeira" -> "Vayeira"
  const PARSHA_EXTRACT_RE = /dvar torah parshas\s+(.+?)(?:\s+-\s+|$)/i;
 


//Order by Parsha
const PARSHA_ORDER = [
  "Bereishis","Noach","Lech Licha","Vayeira","Chayei Sarah","Toldos",
  "Vayeitzei","Vayishlach","Vayeishev","Mekeitz","Vayigash","Vayichi",

  "Shemos","Vaeira","Bo","Beshalach","Yisro","Mishpatim",
  "Terumah","Tetzaveh","Ki Sisa","Vayakhel","Pekudei",

  "Vayikra","Tzav","Shemini","Tazria","Metzora",
  "Achrei Mos","Kedoshim","Emor","Behar","Bechukosai",

  "Bamidbar","Naso","Behaaloscha","Shelach","Korach",
  "Chukas","Balak","Pinchas","Matos","Masei",

  "Devarim","Vaeschanan","Eikev","Reeh","Shoftim",
  "Ki Seitzei","Ki Savo","Nitzavim","Vayeilech",
  "Haazinu","Vezos Haberacha"
];


  // =============================
  // Helpers
  // =============================
  const $ = (id) => document.getElementById(id);
  const grid = $("grid");
  const empty = $("empty");
  const q = $("q");
  const sort = $("sort");
  const parshaSel = $("parsha");
  
  const linksBox = $("linksBox");
const linksList = $("linksList");
const linksTitle = $("linksTitle");
const linksHint = $("linksHint");
const pageH1 = $("pageH1");

// Per-Parsha extra links shown when a Parsha is selected.
// Add as many as you want per Parsha.
const PARSHA_AUDIO = {
  "Noach": [
    { label: "How petty theft sealed the fate of the dor hamabul", url: "https://www.buzzsprout.com/1899789/episodes/18540770-1-20-2025-shloimy-zelcer-double-black-tefilin.mp3", duration: "5:42"}
  ],
  "Bereishis": [
    { label: "Parsha page (Google Site)", url: "https://sites.google.com/VIEW/BEREISHIS" }
  ]
};

// Optional: links shown when "All Parshios" is selected (site-wide links)
const GLOBAL_LINKS = [
  { label: "Back to Parshios index", url: "https://sites.google.com/VIEW/PARSHIOS" },
  { label: "TorahMoment YouTube", url: "https://youtube.com/@torahmoment" }
];

  
  const clearBtn = $("clear");
  const count = $("count");
  const statusText = $("statusText");
  const statusSmall = $("statusSmall");

  const ytWatch = (id) => `https://www.youtube.com/watch?v=${id}`;
  const fmtDate = (iso) => {
    try {
      const d = new Date(iso);
      return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
    } catch { return ""; }
  };
  const escapeHtml = (s) => String(s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
  const normalizeWs = (s) => String(s ?? "").replace(/\s+/g, " ").trim();

function setFiltersOpen(isOpen){
  if (!controlsWrap || !filtersBtn) return;

  controlsWrap.classList.toggle("is-open", isOpen);
  filtersBtn.setAttribute("aria-expanded", String(isOpen));
 filtersBtn.textContent = isOpen ? "Filters ‚ñ≤" : "Filters ‚ñº";

}

if (filtersBtn && controlsWrap) {
  // Start collapsed on mobile, open on desktop
  const mq = window.matchMedia("(max-width: 780px)");
  setFiltersOpen(!mq.matches);

  filtersBtn.addEventListener("click", () => {
    const open = controlsWrap.classList.contains("is-open");
    setFiltersOpen(!open);
  });

  // If user rotates phone / resizes window, adapt
  mq.addEventListener("change", (e) => {
    setFiltersOpen(!e.matches); // mobile => collapsed, desktop => open
  });
}



  function setStatus(main, small="") {
    statusText.textContent = main;
    statusSmall.textContent = small;
  }

  async function api(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status} from YouTube API`);
    return r.json();
  }

  async function getUploadsPlaylistId() {
    const url =
      `https://www.googleapis.com/youtube/v3/channels` +
      `?part=contentDetails&id=${encodeURIComponent(CHANNEL_ID)}` +
      `&key=${encodeURIComponent(API_KEY)}`;
    const j = await api(url);
    const pid = j.items?.[0]?.contentDetails?.relatedPlaylists?.uploads;
    if (!pid) throw new Error("Could not find uploads playlist id.");
    return pid;
  }

  async function getAllVideoIdsFromPlaylist(playlistId) {
    let ids = [];
    let pageToken = "";
    while (true) {
      const url =
        `https://www.googleapis.com/youtube/v3/playlistItems` +
        `?part=contentDetails&maxResults=50&playlistId=${encodeURIComponent(playlistId)}` +
        (pageToken ? `&pageToken=${encodeURIComponent(pageToken)}` : "") +
        `&key=${encodeURIComponent(API_KEY)}`;

      const j = await api(url);
      const chunk = (j.items || []).map(it => it.contentDetails?.videoId).filter(Boolean);
      ids.push(...chunk);

      setStatus("Loading‚Ä¶", `Fetched ${ids.length} video IDs`);
      if (ids.length >= MAX_TO_FETCH) break;

      pageToken = j.nextPageToken;
      if (!pageToken) break;
    }
    return ids;
  }

  async function getVideoDetails(videoIds) {
    const out = [];
    for (let i = 0; i < videoIds.length; i += 50) {
      const batch = videoIds.slice(i, i + 50);
      const url =
        `https://www.googleapis.com/youtube/v3/videos` +
        `?part=snippet&id=${encodeURIComponent(batch.join(","))}` +
        `&key=${encodeURIComponent(API_KEY)}`;
      const j = await api(url);

      for (const it of (j.items || [])) {
        const s = it.snippet || {};
        const thumbs = s.thumbnails || {};
        out.push({
          id: it.id,
          title: s.title || "",
          publishedAt: s.publishedAt || "",
          description: s.description || "",
          thumb:
            thumbs.maxres?.url ||
            thumbs.standard?.url ||
            thumbs.high?.url ||
            thumbs.medium?.url ||
            thumbs.default?.url ||
            ""
        });
      }
      setStatus("Loading‚Ä¶", `Loaded details for ${Math.min(i + 50, videoIds.length)} / ${videoIds.length}`);
    }
    return out;
  }

function setPageTitle() {
  const base = "Parsha Divrei Torah";
  const p = parshaSel.value;

  const full = p ? `${base} ‚Äì ${p}` : base;

  document.title = full;
  if (pageH1) pageH1.textContent = full;
}


function updateURLFromSelection() {
  const url = new URL(window.location.href);

  if (parshaSel.value) {
    url.searchParams.set("parsha", parshaSel.value);
  } else {
    url.searchParams.delete("parsha");
  }

  // Update address bar without reloading the page
  history.replaceState({}, "", url.toString());
}


  function isParshaVideo(desc) {
    return (desc || "").toLowerCase().includes(PARSHA_DESC_NEEDLE);
  }

  function extractParsha(desc) {
    const firstLine = normalizeWs(String(desc || "").split("\n")[0] || "");
    const m = firstLine.match(PARSHA_EXTRACT_RE);
    if (!m) return "";
    // Title-case-ish cleanup
    return normalizeWs(m[1]);
  }

  // =============================
  // State + UI
  // =============================
  let parshaVideos = []; // all parsha videos
  let parshaList = [];   // unique parsha names

  function buildParshaDropdown() {
    // Keep current selection if possible
    const current = parshaSel.value;

    parshaSel.innerHTML = `<option value="">All Parshios</option>`;
    for (const p of parshaList) {
      const opt = document.createElement("option");
      opt.value = p;
      opt.textContent = p;
      parshaSel.appendChild(opt);
    }
    // restore if still valid
    if ([...parshaSel.options].some(o => o.value === current)) parshaSel.value = current;
  }


function escapeAttr(s){
  return String(s ?? "").replace(/"/g, "&quot;");
}

function renderLinks() {
  const selected = parshaSel.value;

  // Only show audio when a Parsha is selected
const items = selected && (typeof PARSHA_AUDIO !== "undefined") && PARSHA_AUDIO[selected]
  ? PARSHA_AUDIO[selected]
  : [];


  if (!items.length) {
    linksBox.style.display = "none";
    linksList.innerHTML = "";
    return;
  }

  linksBox.style.display = "block";
  linksTitle.textContent = `Audio playlist for ${selected}`;
  linksHint.textContent = `${items.length} track${items.length === 1 ? "" : "s"}`;

  linksList.innerHTML = items.map(l => `
    <a class="audioLink" href="${escapeAttr(l.url)}" target="_blank" rel="noopener">
      <span class="playBtn" aria-hidden="true">
        <span class="playIcon"></span>
      </span>

      <span class="audioTitle">${escapeHtml(l.label)}</span>

      <span class="audioMeta">
        ${l.duration ? `<span>(${escapeHtml(l.duration)})</span>` : ""}
        <span class="audioBadge">Audio only</span>
      </span>
    </a>
  `).join("");
}

function getParshaFromURL() {
  const params = new URLSearchParams(window.location.search);
  const p = params.get("parsha");
  return p ? p.trim() : "";
}

function normParsha(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/[\u2019']/g, "")
    .replace(/[^a-z0-9]+/g, " ")
    .trim()
    .replace(/\s+/g, " ");
}

function applyFilters() {
  const term = q.value.trim().toLowerCase();
  const selectedParsha = parshaSel.value;

  let list = parshaVideos.slice();

  // ‚úÖ Filter by parsha selection
  if (selectedParsha) {
    const wanted = normParsha(selectedParsha);
    list = list.filter(v => normParsha(v.parsha) === wanted);
  }

  // Search filter
  if (term) {
    list = list.filter(v => (v.title + " " + v.description + " " + v.parsha).toLowerCase().includes(term));
  }

  // Sort
  const mode = sort.value;
  if (mode === "new") list.sort((a,b) => (b.publishedAt || "").localeCompare(a.publishedAt || ""));
  if (mode === "old") list.sort((a,b) => (a.publishedAt || "").localeCompare(b.publishedAt || ""));
  if (mode === "title") list.sort((a,b) => (a.title || "").localeCompare(b.title || ""));

  render(list);
}


function selectParshaFromURL() {
  const wantedRaw = getParshaFromURL();
  if (!wantedRaw) return false;

  const wanted = normParsha(wantedRaw);

  // Build a lookup of normalized option value -> real option value
  const map = new Map();
  for (const opt of parshaSel.options) {
    if (!opt.value) continue;
    map.set(normParsha(opt.value), opt.value);
  }

  const actual = map.get(wanted);
  if (!actual) return false;

  parshaSel.value = actual;
  return true;
}



  function applyFilters() {
    const term = q.value.trim().toLowerCase();
    const selectedParsha = parshaSel.value;

    let list = parshaVideos.slice();

    if (selectedParsha) {
      list = list.filter(v => v.parsha === selectedParsha);
    }

    if (term) {
      list = list.filter(v => (v.title + " " + v.description + " " + v.parsha).toLowerCase().includes(term));
    }

    const mode = sort.value;
    if (mode === "new") list.sort((a,b) => (b.publishedAt || "").localeCompare(a.publishedAt || ""));
    if (mode === "old") list.sort((a,b) => (a.publishedAt || "").localeCompare(b.publishedAt || ""));
    if (mode === "title") list.sort((a,b) => (a.title || "").localeCompare(b.title || ""));

    render(list);
  }

  function render(list) {
    grid.innerHTML = "";
    empty.style.display = list.length ? "none" : "block";
    count.textContent = `${list.length} video${list.length === 1 ? "" : "s"} shown`;

    for (const v of list) {
      const a = document.createElement("a");
      a.className = "card";
      a.href = ytWatch(v.id);
      a.target = "_blank";
      a.rel = "noopener";

      const desc = normalizeWs((v.description || "").split("\n")[0] || "");
      const shortDesc = desc.length > 110 ? (desc.slice(0, 110) + "‚Ä¶") : desc;

      a.innerHTML = `
        <span class="thumb">
          <img loading="lazy" src="${escapeHtml(v.thumb)}" alt="${escapeHtml(v.title)} thumbnail" />
          <span class="play" aria-hidden="true">
            <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="32" cy="32" r="28" fill="rgba(255,255,255,.90)"/>
              <path d="M27 22.5V41.5L43 32L27 22.5Z" fill="rgba(17,24,39,.95)"/>
            </svg>
          </span>
        </span>
        <div class="meta">
          <h3>${escapeHtml(v.title)}</h3>
          <p class="date">${escapeHtml(fmtDate(v.publishedAt))}</p>
          ${shortDesc ? `<p class="desc">${escapeHtml(shortDesc)}</p>` : ""}
          <div class="pillrow">
            ${v.parsha ? `<span class="pill">${escapeHtml(v.parsha)}</span>` : `<span class="pill">Parsha</span>`}
            <span class="pill">YouTube</span>
          </div>
        </div>
      `;
      grid.appendChild(a);
    }
  }

  async function load() {
    if (!API_KEY || API_KEY === "PASTE_YOUR_API_KEY_HERE") {
      setStatus("Missing API key", "Paste your key into API_KEY at the top of this file.");
      grid.innerHTML = "";
      empty.style.display = "block";
      count.textContent = "";
      return;
    }

    try {
      setStatus("Starting‚Ä¶", "Finding uploads playlist");
      const uploadsPlaylistId = await getUploadsPlaylistId();

      setStatus("Loading‚Ä¶", "Fetching all video IDs");
      const ids = await getAllVideoIdsFromPlaylist(uploadsPlaylistId);

      setStatus("Loading‚Ä¶", `Found ${ids.length}. Fetching details‚Ä¶`);
      const details = await getVideoDetails(ids);

      setStatus("Filtering‚Ä¶", "Keeping Parsha videos (by description)");
      parshaVideos = details
        .filter(v => isParshaVideo(v.description))
        .map(v => ({ ...v, parsha: extractParsha(v.description) }))
        .filter(v => !!v.id);

      parshaList = Array.from(new Set(parshaVideos.map(v => v.parsha).filter(Boolean)))
  .sort((a, b) => {
    const ia = PARSHA_ORDER.indexOf(a);
    const ib = PARSHA_ORDER.indexOf(b);

    // Known parshios ‚Üí Torah order
    if (ia !== -1 && ib !== -1) return ia - ib;

    // Known comes before unknown
    if (ia !== -1) return -1;
    if (ib !== -1) return 1;

    // Fallback alphabetical
    return a.localeCompare(b);
  });



buildParshaDropdown();
selectParshaFromURL();

setPageTitle();              // ‚úÖ new
updateURLFromSelection();    // ‚úÖ new (normalizes URL)

renderLinks();
applyFilters();





const parshaFromURL = getParshaFromURL();
if (parshaFromURL && [...parshaSel.options].some(o => o.value === parshaFromURL)) {
  parshaSel.value = parshaFromURL;
}

 

renderLinks();


      setStatus("Done", `Loaded ${parshaVideos.length} Parsha videos across ${parshaList.length} Parshios.`);
      applyFilters();
    } catch (e) {
      setStatus("Error", e.message || String(e));
      grid.innerHTML = "";
      empty.style.display = "block";
      count.textContent = "";
    }
  }

  // Events
  q.addEventListener("input", applyFilters);
  sort.addEventListener("change", applyFilters);
 parshaSel.addEventListener("change", () => {
  updateURLFromSelection();  // ‚úÖ new
  setPageTitle();            // ‚úÖ new
  renderLinks();
  applyFilters();
  
   if (window.matchMedia("(max-width: 780px)").matches) {
    setFiltersOpen(false);
  }
  
});


  clearBtn.addEventListener("click", () => {
  q.value = "";
  sort.value = "new";
  parshaSel.value = "";

  updateURLFromSelection();  // ‚úÖ new
  setPageTitle();            // ‚úÖ new

  renderLinks();
  applyFilters();
  q.focus();
});


  load();
</script>
</body>
</html>
