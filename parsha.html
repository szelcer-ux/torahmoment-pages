<!doctype html> 
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Parsha Divrei Torah</title>
  <style>
    :root { --radius: 14px; --shadow: 0 10px 28px rgba(0,0,0,.08); }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:#f6f7fb; color:#111827; }
    header { position: sticky; top: 0; z-index: 10; background: rgba(246,247,251,.92); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(17,24,39,.08); }
    .wrap { max-width: 1150px; margin: 0 auto; padding: 14px 16px; }
    h1 { margin: 0; font-size: 24px; letter-spacing: -.02em; }
    .sub { margin: 6px 0 0; color:#6b7280; font-size: 14px; }

    .controls { display:grid; grid-template-columns: 1fr 220px 220px 140px; gap:10px; margin-top:14px; }
    input, select, button { width:100%; border:1px solid rgba(17,24,39,.12); border-radius:12px; padding:10px 12px; font-size:14px; background:#fff; }
    button { cursor:pointer; background:#111827; color:#fff; }
    button:hover { filter: brightness(1.05); }
    @media (max-width: 900px){ .controls{ grid-template-columns: 1fr 1fr; } }
    @media (max-width: 600px){ .controls{ grid-template-columns: 1fr; } }

    main { padding: 18px 0 40px; }
    .bar { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:12px; color:#6b7280; font-size:13px; }
    .grid { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 620px){ .grid{ grid-template-columns: 1fr; } }

    .card { background:#fff; border:1px solid rgba(17,24,39,.08); border-radius: var(--radius); overflow:hidden; box-shadow: var(--shadow); transition: transform .12s ease, box-shadow .12s ease; text-decoration:none; color:inherit; }
    .card:hover { transform: translateY(-2px); box-shadow: 0 14px 34px rgba(0,0,0,.10); }
    .thumb { display:block; width:100%; aspect-ratio: 16/9; background:#e5e7eb; position:relative; overflow:hidden; }
    .thumb img { width:100%; height:100%; object-fit:cover; display:block; }
    .play { position:absolute; inset:0; display:grid; place-items:center; background: linear-gradient(to top, rgba(0,0,0,.45), rgba(0,0,0,0)); opacity:.95; }
    .play svg { width:62px; height:62px; filter: drop-shadow(0 6px 10px rgba(0,0,0,.35)); }

    .meta { padding:12px 12px 14px; }
    .meta h3 { margin:0 0 6px; font-size:16px; line-height:1.25; }
    .meta .date { margin:0; color:#6b7280; font-size:13px; }
    .meta .desc { margin:8px 0 0; color:#6b7280; font-size:13px; line-height:1.35; }
    .pillrow { margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
    .pill { display:inline-block; font-size:12px; padding:6px 9px; border-radius:999px; background:#f3f4f6; border:1px solid rgba(17,24,39,.08); color:#111827; }

    .empty, .notice { background:#fff; border-radius: var(--radius); padding:16px; color:#6b7280; text-align:center; }
    .empty { border:1px dashed rgba(17,24,39,.25); }
    .notice { border:1px solid rgba(17,24,39,.10); margin-bottom:12px; }
    .small { font-size:12px; color:#6b7280; }
    code { background:#f3f4f6; padding:2px 6px; border-radius:8px; }
	
	.linksBox{
  background:#fff;
  border:1px solid rgba(17,24,39,.08);
  border-radius:14px;
  padding:14px;
  margin: 0 0 14px;
  box-shadow: 0 10px 28px rgba(0,0,0,.06);
}
.linksTop{
  display:flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}
.linksTitle{
  font-weight: 700;
  font-size: 15px;
}
.linksHint{
  color:#6b7280;
  font-size: 12px;
}


.audioIcon{
  font-size:16px;
  opacity:0.75;
}

.audioLink{
  color: inherit !important;
  text-decoration: none !important;
}
.audioLink:hover{
  text-decoration: none !important;
}


 .linksList{
  display:flex;
  flex-direction: column;
  gap: 0;                 /* dividers handle spacing */
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid rgba(17,24,39,.10);
  background: #fff;
}

/* Layout: allow title + (optional) scrubber */
.audioMain{
  display:flex;
  flex-direction:column;
  gap:6px;
  min-width:0;
  flex:1 1 auto;
}

/* Scrubber hidden unless row is active */
.audioScrub{ display:none; }
.audioLink.isPlaying .audioScrub,
.audioLink.isPaused  .audioScrub{
  display:flex;
  align-items:center;
  gap:10px;
}

.audioProgress { pointer-events: auto; }

	  
/* Range slider should not stretch weirdly */
.audioProgress{
  flex: 1 1 auto;
  width: 100%;
  max-width: 420px;
  height: 4px;
  padding: 0;
  margin: 0;
  accent-color: #111827; /* uses your theme */
}

/* Time text compact */
.audioTime{
  font-size:12px;
  color:#6b7280;
  white-space:nowrap;
}
.audioSep{ opacity:.7; }

	  
/* Each row */
.audioLink{
  display:flex;
  align-items:center;
  gap:12px;
  padding:12px 12px;
  text-decoration:none;
  color:#111827;
  font-size:14px;
  background:#fff;
  transition: background .12s ease, transform .08s ease;
}

/* Subtle divider between rows */
.audioLink + .audioLink{
  border-top: 1px solid rgba(17,24,39,.08);
}

/* Hover/focus = “media player” feel */
.audioLink:hover{
  background:#f9fafb;
}
.audioLink:active{
  transform: translateY(1px);
}
.audioLink:focus-visible{
  outline: 2px solid rgba(17,24,39,.25);
  outline-offset: -2px;
}

/* Play button in a circle */
.playBtn{
  width: 34px;
  height: 34px;
  border-radius: 999px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#f3f4f6;
  border: 1px solid rgba(17,24,39,.10);
  flex: 0 0 auto;
}

/* Title text */
.audioTitle{
  min-width: 0;               /* enables ellipsis */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Right-side meta: duration + badge */
.audioMeta{
  margin-left: auto;
  display:flex;
  align-items:center;
  gap:8px;
  font-size:12px;
  color:#6b7280;
  flex: 0 0 auto;
}

.audioBadge{
  padding:3px 8px;
  border-radius:999px;
  border:1px solid rgba(17,24,39,.15);
  background:#f3f4f6;
  font-size:11px;
  color:#111827;
  white-space: nowrap;
}



.linksBox {
  margin-top: 24px;
}

/* Mobile: prevent the header from taking over the screen (esp inside Google Sites embeds) */

/* Header row: title + filters */
.headerRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

/* Filters button hidden on desktop */
.filtersBtn{
  display:none;
}

/* Mobile adjustments */
@media (max-width: 780px){
  header{ position: static; backdrop-filter:none; }
  .wrap{ padding:10px 10px; }
  h1{ font-size:18px; line-height:1.2; }
  #pageH1{ margin:0; }

  .notice{ display:none; }

  /* show compact Filters button */
  .filtersBtn{
    display:inline-flex;
    align-items:center;
    gap:4px;
    width:fit-content !important;
    flex:0 0 auto !important;
    padding:4px 8px;
    font-size:12px;
    line-height:1;
    font-weight:600;
    border-radius:999px;
    border:1px solid rgba(17,24,39,.18);
    background:#f9fafb;
    color:#111827;
    cursor:pointer;
    white-space:nowrap;
  }

  /* collapse controls by default on mobile */
  .controls{
    display:none;
    grid-template-columns:1fr;
    gap:8px;
    margin-top:10px;
  }
  .controls.is-open{ display:grid; }

  input, select, button{
    padding:9px 10px;
    font-size:14px;
    border-radius:10px;
  }
}


#audioEl{
  position: absolute;
  left: -9999px;
  width: 1px;
  height: 1px;
  opacity: 0;
}


#playerBar{
  display:none;                      /* JS will set to flex */
  align-items:center !important;
  gap:12px !important;
  width:100% !important;
  box-sizing:border-box !important;

  margin-top:12px !important;
  padding:10px 12px !important;

  border:1px solid rgba(17,24,39,.10) !important;
  border-radius:12px !important;
  background:#fff !important;
}

/* When shown by JS */
#playerBar[style*="display: flex"],
#playerBar[style*="display:flex"]{
  display:flex !important;
}


/* Title */
#playerTitle{
  font-weight:600 !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* Time line */
#playerTime{
  margin-top:4px !important;
  font-size:12px !important;
  color:#6b7280 !important;
  white-space:nowrap !important;
}

/* === INLINE AUDIO PLAYER: FINAL OVERRIDES === */
#playerBar{
  display:flex !important;
  align-items:center !important;
  justify-content:flex-start !important;
  gap:12px !important;
  flex-wrap:nowrap !important;
  width:100% !important;
  box-sizing:border-box !important;
}

/* Hide the real <audio> element so it never affects layout */
#playerBar audio{
  display:none !important;
}

/* Stop ANY button in the bar from stretching full width */
#playerBar button{
  width:auto !important;
  flex:0 0 auto !important;
  display:inline-flex !important;
  align-items:center !important;
  justify-content:center !important;
  white-space:nowrap !important;
}

/* Prevent any text container from overflowing to the right */
#playerBar > *{
  min-width:0 !important;
}

/* The “info” area should shrink with ellipsis instead of pushing out */
#playerBar .playerInfo,
#playerTitle,
#playerTime{
  min-width:0 !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* Title stays on one line */
#playerTitle{
  white-space:nowrap !important;
}

/* Time stays on one line */
#playerTime{
  white-space:nowrap !important;
}

/* Default: play */
.audioLink .playIcon::before{
  content: "▶";
}

/* Playing */
.audioLink.isPlaying .playIcon::before{
  content: "⏸";
}

/* Paused */
.audioLink.isPaused .playIcon::before{
  content: "▶";
}

.audioLink{ cursor:pointer; }

/* --- Make the play button show ONLY the text icon --- */
.playIcon{
  /* kill any existing triangle/border icon technique */
  width: auto !important;
  height: auto !important;
  border: none !important;
  background: none !important;
}

.playIcon::before{
  display: inline-block;
  font-size: 14px;
  line-height: 1;
}

/* Default: play */
.audioLink .playIcon::before{ content: "▶"; }

/* Playing: pause */
.audioLink.isPlaying .playIcon::before{ content: "⏸"; }

/* Paused: play */
.audioLink.isPaused .playIcon::before{ content: "▶"; }

	.playBtn{
  background: none !important;
}

/* Hide real audio element but keep present for mobile browsers */
#audioEl{
  position:absolute;
  left:-9999px;
  width:1px;
  height:1px;
  opacity:0;
}

/* PDF list */
.pdfList{
  display:flex;
  flex-direction:column;
  border-radius: 12px;
  overflow:hidden;
  border: 1px solid rgba(17,24,39,.10);
  background:#fff;
}
.pdfLink{
  display:flex;
  align-items:center;
  gap:12px;
  padding:12px 12px;
  text-decoration:none;
  color:#111827;
  font-size:14px;
  background:#fff;
  transition: background .12s ease, transform .08s ease;
}
.pdfLink + .pdfLink{
  border-top: 1px solid rgba(17,24,39,.08);
}
.pdfLink:hover{ background:#f9fafb; }
.pdfLink:active{ transform: translateY(1px); }

.pdfIcon{
  width:34px;
  height:34px;
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#f3f4f6;
  border:1px solid rgba(17,24,39,.10);
  flex:0 0 auto;
  font-weight:700;
  font-size:12px;
  color:#111827;
}
.pdfTitle{
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

	  
  </style>
</head>
<body>
<header>
  <div class="wrap">
<div class="headerRow">
  <h1 id="pageH1">Parsha Divrei Torah</h1>

  <button id="filtersBtn" class="filtersBtn" type="button"
          aria-expanded="false" aria-controls="controlsWrap">
    Filters
  </button>
</div>


    <div class="controls" id="controlsWrap">
      <input id="q" type="search" placeholder="Search within Parsha videos..." />
      <select id="parsha">
        <option value="">All Parshios</option>
      </select>
      <select id="sort">
        <option value="new">Newest first</option>
        <option value="old">Oldest first</option>
        <option value="title">Title A–Z</option>
      </select>
      <button id="clear">Clear</button>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="notice">
    <div><strong>Status:</strong> <span id="statusText">Ready</span></div>
    <div class="small" id="statusSmall"></div>
  </div>

  <div class="bar">
    <div id="count"></div>
   <div id="audioCountWrap" class="tm-stat">
  <span id="totalAudioCount"></span>
</div>

  </div>
 
  <div id="grid" class="grid"></div>

 
<div id="linksBox" class="linksBox" style="display:none;">
  <div class="linksTop">
    <div class="linksTitle" id="linksTitle">Links</div>
    <div class="linksHint" id="linksHint"></div>
  </div>
  <div id="linksList" class="linksList"></div>
 



</div> 

  <audio id="audioEl" preload="metadata"></audio>
 <div id="empty" class="empty" style="display:none;">No videos match your filters.</div>

	<section id="secAudioShort" class="linksBox" style="display:none;">
  <div class="linksTop">
    <div class="linksTitle">Short Audio Insights</div>
    <div class="linksHint">5–7 minute Torah thoughts on this Parsha</div>
  </div>
  <div id="audioShortList" class="linksList"></div>
</section>

<section id="secAudioLong" class="linksBox" style="display:none;">
  <div class="linksTop">
    <div class="linksTitle">In-Depth Shiurim</div>
    <div class="linksHint">Full-length shiurim for deeper study </div>
  </div>
  <div id="audioLongList" class="linksList"></div>
</section>

<section id="secPdfs" class="linksBox" style="display:none;">
  <div class="linksTop">
    <div class="linksTitle">In the Name of the Parsha</div>
    <div class="linksHint">PDF learning sheets and written insights</div>
  </div>
  <div id="pdfList" class="pdfList"></div>
</section>

<audio id="audioEl" preload="metadata"></audio>


</main>
<script src="/data/site-counts.js"></script>

<script>
  // =============================
  // CONFIG — EDIT THIS
  // =============================
  const API_KEY    = "AIzaSyDbJnY2cPtyyVya7YNzxG0hCju7ikBUWsU";
  const CHANNEL_ID = "UCzx1pweEHKhsIfPkQZbRH4w";
  const MAX_TO_FETCH = 300;

 const filtersBtn = document.getElementById("filtersBtn");
const controlsWrap = document.getElementById("controlsWrap");





  // Your descriptions include: "Dvar Torah Parshas Noach - Living mercifully"
  const PARSHA_DESC_NEEDLE = "dvar torah parshas";

  // Extract the Parsha name from the description.
  // Captures up to the first " - " (or end of line)
  // Examples:
  // "Dvar Torah Parshas Noach - Living mercifully" -> "Noach"
  // "Dvar Torah Parshas Vayeira" -> "Vayeira"
  const PARSHA_EXTRACT_RE = /dvar torah parshas\s+(.+?)(?:\s+-\s+|$)/i;
 


//Order by Parsha
const PARSHA_ORDER = [
  "Bereishis","Noach","Lech Licha","Vayeira","Chayei Sarah","Toldos",
  "Vayeitzei","Vayishlach","Vayeishev","Mekeitz","Vayigash","Vayichi",

  "Shemos","Vaeira","Bo","Beshalach","Yisro","Mishpatim",
  "Terumah","Tetzaveh","Ki Sisa","Vayakhel","Pekudei",

  "Vayikra","Tzav","Shemini","Tazria","Metzora",
  "Achrei Mos","Kedoshim","Emor","Behar","Bechukosai",

  "Bamidbar","Naso","Behaaloscha","Shelach","Korach",
  "Chukas","Balak","Pinchas","Matos","Masei",

  "Devarim","Vaeschanan","Eikev","Reeh","Shoftim",
  "Ki Seitzei","Ki Savo","Nitzavim","Vayeilech",
  "Haazinu","Vezos Haberacha"
];


  // =============================
  // Helpers
  // =============================
  const $ = (id) => document.getElementById(id);
  const grid = $("grid");
  const empty = $("empty");
  const q = $("q");
  const sort = $("sort");
  const parshaSel = $("parsha");
  
  const linksBox = $("linksBox");
const linksList = $("linksList");
const linksTitle = $("linksTitle");
const linksHint = $("linksHint");
const pageH1 = $("pageH1");

// Per-Parsha extra links shown when a Parsha is selected.
// Add as many as you want per Parsha.
const PARSHA_AUDIO = {
  "Noach": [
    { label: "How petty theft sealed the fate of the dor hamabul", url: "https://www.buzzsprout.com/1899789/episodes/16010930-10-29-2024-shloimy-zelcer-how-petty-theft-sealed-the-fate-of-the-dor-hamabul.mp3", duration: "5:28"}
  ],
	 "Vayeira": [
    { label: "Divrei Chizuk for RCCS", url: "https://2mishnasaday.com/wp-content/uploads/Rccs.mp3", duration: "7:56"}
  ],
  "Vayeitzei": [
    { label: "הפעם אודה את ה", url: "https://www.buzzsprout.com/1899789/episodes/14012119-11-21-2023-shloimy-zelcer.mp3", duration: "3:55" },
	{ label: "Jacob's ladder as a paradigm for prayer", url: "https://www.buzzsprout.com/1899789/episodes/18244005-11-24-2025-shloimy-zelcer-jacob-s-ladder-as-a-paradigm-for-prayer.mp3", duration: "4:54" }
  ],
   "Vayishlach": [
    { label: "When preparing to battle Eisav, what was Yaakov so scared of and why?", url: "https://www.buzzsprout.com/1899789/episodes/9678548-11-17-2021-shloimy-zelcer.mp3", duration: "5:07" }
  ],
  "Vayeishev": [
    { label: "Yosef's multifaceted personality", url: "https://www.buzzsprout.com/1899789/episodes/14089027-12-4-2023-shloimy-zelcer.mp3", duration: "4:08" }
  ],
    "Vaeira": [
    { label: "Appreciating Hashem's kindness", url: "https://www.buzzsprout.com/1899789/episodes/16511618-1-27-2025-shloimy-zelcer-appreciating-hashems-kindness.mp3", duration: "4:33" }
  ],
    "Vayikra": [
    { label: "Brief Intro to Sefer Vayikra", url: "https://www.buzzsprout.com/1899789/episodes/14711013-3-18-2024-shloimy-zelcer.mp3", duration: "4:24" }
  ],
    "Shemini": [
    { label: "יום השמיני - a busy day", url: "https://www.buzzsprout.com/1899789/episodes/14806560-4-1-2024-shloimy-zelcer-a-busy-day.mp3", duration: "4:53" }
  ],
  "Shelach": [
    { label: "A lesson from the parsha of the Meraglim", url: "https://www.buzzsprout.com/1899789/episodes/13024292-6-12-2023-shloimy-zelcer.mp3", duration: "5:10" },
	{ label: "Lessons from the terrible sin of the spies", url: "https://www.buzzsprout.com/1899789/episodes/10842600-6-21-2022-shloimy-zelcer.mp3", duration: "7:22" }
  ], 
    "Vaeschanan": [
    { label: "My rebbis legacy - always pushing for greatness", url: "https://www.buzzsprout.com/1899789/episodes/17624623-8-6-2025-shloimy-zelcer-my-rebbis-legacy-always-pushing-for-greatness.mp3", duration: "5:29" }
  ],
  "Shoftim": [
    { label: "Selective observance", url: "https://www.buzzsprout.com/1899789/episodes/17736499-8-26-2025-shloimy-zelcer-selective-observance.mp3", duration: "5:14" }
  ]
};

const PARSHA_INDEPTH = {
  "Noach": [
     { label: "Rebelling Against the Government", url: "https://2mishnasaday.com/wp-content/uploads/noachrebellingagainstthegovernment.mp3", duration: "33:32" }	   
  ],
	"Vayeira": [
     { label: "Angels and Prophesy", url: "https://2mishnasaday.com/wp-content/uploads/vayeramalachim.mp3", duration: "55:42" }	   
  ],
	"Vayigash": [
     { label: "Why didn't Yosef contact Yaakov?", url: "https://2mishnasaday.com/wp-content/uploads/whydidntyosefcontactyaakov.mp3", duration: "54:54" }	   
  ],
   "Vayakhel": [
    { label: "Some famous Rashi's from the parsha", url: "https://2mishnasaday.com/wp-content/uploads/vayakhel.mp3", duration: "35:21" }
	   		  ],
	 "Vayikra": [
    { label: "Intro to Vayikrah", url: "https://2mishnasaday.com/wp-content/uploads/IntrotoVayikrahZoommp3.mp3", duration: "29:02" }
	   		  ],
	"Achrei Mos": [
    { label: "Parshas Achrei Mos", url: "https://2mishnasaday.com/wp-content/uploads/achreizoomFINAL.mp3", duration: "46:43" }
	   		  ],
		"Behar": [
    { label: "Aliyas Regalim today", url: "https://2mishnasaday.com/wp-content/uploads/BEHARaliyasregalim.mp3", duration: "43:47" }
	   		  ],
	"Devarim": [
    { label: "Intro to Devarim: Begining of Torah Shebal Peh?", url: "https://2mishnasaday.com/wp-content/uploads/introdevarimfinal.mp3", duration: "46:19" }
	   		  ]
	
};

	const PARSHA_PDFS = {
  "Noach": [
    { label: "Noach - The light in the darkness", url: "https://drive.google.com/file/d/1-uLZ9gDqXG4gtpLRqmTNzXWhnymfoJ7Q/view?usp=sharing" }
  ],
  // ...
};



	function getCurrentParsha() {
  const sel = document.getElementById("parsha");
  if (sel) return sel.value; // returns "" for All (good)

  const p = new URLSearchParams(location.search).get("parsha");
  if (p) return p;

  return ""; // default to All
}


	
// Optional: links shown when "All Parshios" is selected (site-wide links)
const GLOBAL_LINKS = [
  { label: "Back to Parshios index", url: "https://sites.google.com/VIEW/PARSHIOS" },
  { label: "TorahMoment YouTube", url: "https://youtube.com/@torahmoment" }
];

  
  const clearBtn = $("clear");
  const count = $("count");
  const statusText = $("statusText");
  const statusSmall = $("statusSmall");

  const ytWatch = (id) => `https://www.youtube.com/watch?v=${id}`;
  const fmtDate = (iso) => {
    try {
      const d = new Date(iso);
      return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
    } catch { return ""; }
  };
  const escapeHtml = (s) => String(s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
  const normalizeWs = (s) => String(s ?? "").replace(/\s+/g, " ").trim();

function clearAudioRowStates(){
  document.querySelectorAll(".audioLink").forEach(row => {
    row.classList.remove("isPlaying", "isPaused");
  });
}

function countAllItems(obj) {
  if (!obj) return 0;
  if (Array.isArray(obj)) return obj.length;
  return Object.values(obj).reduce(
    (sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0),
    0
  );
}

setTimeout(() => {
  if (!window.SITE_COUNTS?.allShiurim?.breakdown) return;

  const audioShort = countAllItems(PARSHA_AUDIO);
  const audioLong  = countAllItems(typeof PARSHA_INDEPTH !== "undefined" ? PARSHA_INDEPTH :
                                   (typeof PARSHA_IN_DEPTH !== "undefined" ? PARSHA_IN_DEPTH : null));

  let videoTotal = 0;
try {
  videoTotal = (typeof parshaVideos !== "undefined" && Array.isArray(parshaVideos)) ? parshaVideos.length : 0;
} catch {
  // parshaVideos not initialized yet (temporal dead zone) — treat as 0 for now
  videoTotal = 0;
}


  window.SITE_COUNTS.allShiurim.breakdown.parsha.audio = audioShort + audioLong;
  window.SITE_COUNTS.allShiurim.breakdown.parsha.video = videoTotal;

  const b = window.SITE_COUNTS.allShiurim.breakdown;
  const n = (x) => (typeof x === "number" ? x : 0);

  window.SITE_COUNTS.allShiurim.total =
    n(b.parsha.audio) + n(b.parsha.video) +
    n(b.tefila.video) + n(b.halacha.audio) + n(b.oneMinute.audio);

  window.SITE_COUNTS.allShiurim.updated = new Date().toISOString().slice(0, 10);

  console.log("Updated parsha counts:", window.SITE_COUNTS.allShiurim.breakdown.parsha);
}, 0);



	
function escapeAttr(s){ return escapeHtml(s); }

function setSectionVisible(sectionId, hasItems){
  const sec = document.getElementById(sectionId);
  if (!sec) return;
  sec.style.display = hasItems ? "block" : "none";
}
function countAllItems(obj) {
  if (!obj) return 0;
  if (Array.isArray(obj)) return obj.length;
  if (typeof obj === "object") {
    return Object.values(obj).reduce((sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0), 0);
  }
  return 0;
}

function safeGet(name) {
  try { return Function("return typeof " + name + " !== 'undefined' ? " + name + " : undefined")(); }
  catch { return undefined; }
}

function renderAudioList(containerId, items){
  const el = document.getElementById(containerId);
  if (!el) return;

  el.innerHTML = (items || []).map(it => `
    <div class="audioLink" role="button" tabindex="0"
         data-href="${escapeAttr(it.url)}"
         data-title="${escapeAttr(it.label)}">
      <span class="playBtn"><span class="playIcon"></span></span>

      <span class="audioMain">
        <span class="audioTitle">${escapeHtml(it.label)}</span>

        <span class="audioScrub">
          <input class="audioProgress" type="range" min="0" max="1000" value="0" step="1" aria-label="Audio progress" />
          <span class="audioTime">
            <span class="audioCur">0:00</span>
            <span class="audioSep"> / </span>
            <span class="audioDur">0:00</span>
          </span>
        </span>
      </span>

      <span class="audioMeta">
        ${it.duration ? `<span class="audioDuration">${escapeHtml(it.duration)}</span>` : ``}
        <span class="audioBadge">Audio</span>
      </span>
    </div>
  `).join("");
}

function updateParshaCounts() {
  if (!window.SITE_COUNTS?.allShiurim?.breakdown) return;

  const countAllItems = (obj) => {
    if (!obj) return 0;
    if (Array.isArray(obj)) return obj.length;
    return Object.values(obj).reduce((s, a) => s + (Array.isArray(a) ? a.length : 0), 0);
  };

  const audioShort = countAllItems(PARSHA_AUDIO);
  const audioLong  = countAllItems(typeof PARSHA_INDEPTH !== "undefined" ? PARSHA_INDEPTH :
                                   (typeof PARSHA_IN_DEPTH !== "undefined" ? PARSHA_IN_DEPTH : null));

  let videoTotal = 0;
  try {
    videoTotal = (typeof parshaVideos !== "undefined" && Array.isArray(parshaVideos)) ? parshaVideos.length : 0;
  } catch {
    videoTotal = 0;
  }

  window.SITE_COUNTS.allShiurim.breakdown.parsha.audio = audioShort + audioLong;
  window.SITE_COUNTS.allShiurim.breakdown.parsha.video = videoTotal;
  window.SITE_COUNTS.allShiurim.updated = new Date().toISOString().slice(0, 10);

  window.__COUNTS_READY__ = window.__COUNTS_READY__ || {};
  window.__COUNTS_READY__.parsha = (videoTotal > 0);

  console.log("✅ Updated Parsha counts:", window.SITE_COUNTS.allShiurim.breakdown.parsha,
              "READY:", window.__COUNTS_READY__.parsha);
}



function renderPdfList(containerId, items){
  const el = document.getElementById(containerId);
  if (!el) return;

  el.innerHTML = (items || []).map(it => `
    <a class="pdfLink" href="${escapeAttr(it.url)}" target="_blank" rel="noopener">
      <span class="pdfIcon">PDF</span>
      <span class="pdfTitle">${escapeHtml(it.label)}</span>
    </a>
  `).join("");
}

	function countAllItems(obj) {
  if (!obj) return 0;
  return Object.values(obj).reduce(
    (sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0),
    0
  );
}


	
function renderParshaExtras(parsha) {
  // No selection => hide everything
  if (!parsha) {
    setSectionVisible("secAudioShort", false);
    setSectionVisible("secAudioLong",  false);
    setSectionVisible("secPdfs",       false);

    const wrap = document.getElementById("audioCountWrap");
    if (wrap) wrap.style.display = "none";

    clearAudioRowStates();
    return;
  }

  const shortItems = (PARSHA_AUDIO && PARSHA_AUDIO[parsha]) ? PARSHA_AUDIO[parsha] : [];
  const longItems  = (PARSHA_INDEPTH && PARSHA_INDEPTH[parsha]) ? PARSHA_INDEPTH[parsha] : [];
  const pdfItems   = (PARSHA_PDFS && PARSHA_PDFS[parsha]) ? PARSHA_PDFS[parsha] : [];

  setSectionVisible("secAudioShort", shortItems.length > 0);
  setSectionVisible("secAudioLong",  longItems.length  > 0);
  setSectionVisible("secPdfs",       pdfItems.length   > 0);

  renderAudioList("audioShortList", shortItems);
  renderAudioList("audioLongList",  longItems);
  renderPdfList("pdfList",          pdfItems);

  clearAudioRowStates();

  // Counter
  const wrap = document.getElementById("audioCountWrap");
  const el   = document.getElementById("totalAudioCount");
  if (wrap && el) {
    const total = shortItems.length + longItems.length;
    wrap.style.display = total ? "" : "none";
    if (total) el.textContent = `${parsha}: ${total.toLocaleString()} audio shiurim`;
  }
}


	
function setFiltersOpen(isOpen){
  if (!controlsWrap || !filtersBtn) return;

  controlsWrap.classList.toggle("is-open", isOpen);
  filtersBtn.setAttribute("aria-expanded", String(isOpen));
 filtersBtn.textContent = isOpen ? "Filters ▲" : "Filters ▼";

}

if (filtersBtn && controlsWrap) {
  // Start collapsed on mobile, open on desktop
  const mq = window.matchMedia("(max-width: 780px)");
  setFiltersOpen(!mq.matches);

  filtersBtn.addEventListener("click", () => {
    const open = controlsWrap.classList.contains("is-open");
    setFiltersOpen(!open);
  });

  // If user rotates phone / resizes window, adapt
  mq.addEventListener("change", (e) => {
    setFiltersOpen(!e.matches); // mobile => collapsed, desktop => open
  });
}



  function setStatus(main, small="") {
    statusText.textContent = main;
    statusSmall.textContent = small;
  }

  async function api(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status} from YouTube API`);
    return r.json();
  }

  const UPLOADS_PLAYLIST_ID = "UUzx1pweEHKhsIfPkQZbRH4w";

async function getUploadsPlaylistId() {
  return UPLOADS_PLAYLIST_ID;
}


  async function getAllVideoIdsFromPlaylist(playlistId) {
    let ids = [];
    let pageToken = "";
    while (true) {
      const url =
        `https://www.googleapis.com/youtube/v3/playlistItems` +
        `?part=contentDetails&maxResults=50&playlistId=${encodeURIComponent(playlistId)}` +
        (pageToken ? `&pageToken=${encodeURIComponent(pageToken)}` : "") +
        `&key=${encodeURIComponent(API_KEY)}`;

      const j = await api(url);
      const chunk = (j.items || []).map(it => it.contentDetails?.videoId).filter(Boolean);
      ids.push(...chunk);

      setStatus("Loading…", `Fetched ${ids.length} video IDs`);
      if (ids.length >= MAX_TO_FETCH) break;

      pageToken = j.nextPageToken;
      if (!pageToken) break;
    }
    return ids;
  }

  async function getVideoDetails(videoIds) {
    const out = [];
    for (let i = 0; i < videoIds.length; i += 50) {
      const batch = videoIds.slice(i, i + 50);
      const url =
        `https://www.googleapis.com/youtube/v3/videos` +
        `?part=snippet&id=${encodeURIComponent(batch.join(","))}` +
        `&key=${encodeURIComponent(API_KEY)}`;
      const j = await api(url);

      for (const it of (j.items || [])) {
        const s = it.snippet || {};
        const thumbs = s.thumbnails || {};
        out.push({
          id: it.id,
          title: s.title || "",
          publishedAt: s.publishedAt || "",
          description: s.description || "",
          thumb:
            thumbs.maxres?.url ||
            thumbs.standard?.url ||
            thumbs.high?.url ||
            thumbs.medium?.url ||
            thumbs.default?.url ||
            ""
        });
      }
      setStatus("Loading…", `Loaded details for ${Math.min(i + 50, videoIds.length)} / ${videoIds.length}`);
    }
    return out;
  }

function fmtTime(sec){
  if (!isFinite(sec) || sec < 0) return "0:00";
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, "0")}`;
}

function updatePlayingRow(){
  document.querySelectorAll(".audioLink").forEach(a => {
    a.classList.toggle("isPlaying", a.getAttribute("href") === currentlyPlayingHref);
  });
}



function setPageTitle() {
  const base = "Parsha Divrei Torah";
  const p = parshaSel.value;

  const full = p ? `${base} – ${p}` : base;

  document.title = full;
  if (pageH1) pageH1.textContent = full;
}


function updateURLFromSelection() {
  const url = new URL(window.location.href);

  if (parshaSel.value) {
    url.searchParams.set("parsha", parshaSel.value);
  } else {
    url.searchParams.delete("parsha");
  }

  // Update address bar without reloading the page
  history.replaceState({}, "", url.toString());
}


  function isParshaVideo(desc) {
    return (desc || "").toLowerCase().includes(PARSHA_DESC_NEEDLE);
  }

  function extractParsha(desc) {
    const firstLine = normalizeWs(String(desc || "").split("\n")[0] || "");
    const m = firstLine.match(PARSHA_EXTRACT_RE);
    if (!m) return "";
    // Title-case-ish cleanup
    return normalizeWs(m[1]);
  }


  // =============================
  // State + UI
  // =============================
  let parshaVideos = []; // all parsha videos
  let parshaList = [];   // unique parsha names

  function buildParshaDropdown() {
  const current = parshaSel.value;

  parshaSel.innerHTML = `<option value="" selected disabled>Pick a Parsha…</option>`;
  for (const p of parshaList) {
    const opt = document.createElement("option");
    opt.value = p;
    opt.textContent = p;
    parshaSel.appendChild(opt);
  }

  // restore if still valid
  if ([...parshaSel.options].some(o => o.value === current)) parshaSel.value = current;
}



function escapeAttr(s){
  return String(s ?? "").replace(/"/g, "&quot;");
}

function renderLinks() {
  const selected = parshaSel.value;

  // Only show audio when a Parsha is selected
const items = selected && (typeof PARSHA_AUDIO !== "undefined") && PARSHA_AUDIO[selected]
  ? PARSHA_AUDIO[selected]
  : [];


  if (!items.length) {
    linksBox.style.display = "none";
    linksList.innerHTML = "";
    return;
  }

  linksBox.style.display = "block";
  linksTitle.textContent = `Audio playlist for ${selected}`;
  linksHint.textContent = `${items.length} track${items.length === 1 ? "" : "s"}`;

  linksList.innerHTML = items.map(l => `
  <a class="audioLink"
     href="${escapeAttr(l.url)}"
     data-title="${escapeAttr(l.label)}">

    <span class="playBtn" aria-hidden="true">
      <span class="playIcon"></span>
    </span>

    <span class="audioTitle">${escapeHtml(l.label)}</span>

    <span class="audioMeta">
      <span>(${escapeHtml(l.duration)})</span>
      <span class="audioBadge">Audio only</span>
    </span>
  </a>
`).join("");

}

function getParshaFromURL() {
  const params = new URLSearchParams(window.location.search);
  const p = params.get("parsha");
  return p ? p.trim() : "";
}

function normParsha(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/[\u2019']/g, "")
    .replace(/[^a-z0-9]+/g, " ")
    .trim()
    .replace(/\s+/g, " ");
}




function selectParshaFromURL() {
  const wantedRaw = getParshaFromURL();
  if (!wantedRaw) return false;

  const wanted = normParsha(wantedRaw);

  // Build a lookup of normalized option value -> real option value
  const map = new Map();
  for (const opt of parshaSel.options) {
    if (!opt.value) continue;
    map.set(normParsha(opt.value), opt.value);
  }

  const actual = map.get(wanted);
  if (!actual) return false;

  parshaSel.value = actual;
  return true;
}



 function applyFilters() {
  const term = q.value.trim().toLowerCase();
  const selectedParsha = parshaSel.value;

  // If no selection allowed yet, show nothing
  if (!selectedParsha) {
    render([]);
    empty.style.display = "block";
    empty.textContent = "Pick a Parsha to begin.";
    count.textContent = "";
    return;
  }

  let list = parshaVideos.slice();

  // ✅ normalized parsha filter
  const wanted = normParsha(selectedParsha);
  list = list.filter(v => normParsha(v.parsha) === wanted);

  if (term) {
    list = list.filter(v =>
      (v.title + " " + v.description + " " + v.parsha).toLowerCase().includes(term)
    );
  }

  const mode = sort.value;
  if (mode === "new") list.sort((a,b) => (b.publishedAt || "").localeCompare(a.publishedAt || ""));
  if (mode === "old") list.sort((a,b) => (a.publishedAt || "").localeCompare(b.publishedAt || ""));
  if (mode === "title") list.sort((a,b) => (a.title || "").localeCompare(b.title || ""));

  render(list);
}


function countParshaAudio(data, parsha) {
  if (!data) return 0;

  // All Parshas selected
  if (!parsha || parsha === "All") {
    return Object.values(data).reduce(
      (sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0),
      0
    );
  }

  // Single Parsha
  return Array.isArray(data[parsha]) ? data[parsha].length : 0;
}

	function updateAudioCounter(selectedParsha) {
  const shortCount = countParshaAudio(PARSHA_AUDIO, selectedParsha);
  const longCount  = countParshaAudio(PARSHA_IN_DEPTH, selectedParsha);

  const total = shortCount + longCount;

  const wrap = document.getElementById("audioCountWrap");
  const el   = document.getElementById("totalAudioCount");
  if (!wrap || !el) return;

  // Hide entirely if nothing to show
  if (total === 0) {
    wrap.style.display = "none";
    return;
  }

  wrap.style.display = "";

  if (!selectedParsha || selectedParsha === "All") {
    el.textContent = `Total audio shiurim: ${total.toLocaleString()}`;
  } else {
    el.textContent = `${selectedParsha}: ${total.toLocaleString()} audio shiurim`;
  }
}

	
  function render(list) {
    grid.innerHTML = "";
    empty.style.display = list.length ? "none" : "block";
    count.textContent = `${list.length} video${list.length === 1 ? "" : "s"} shown`;

    for (const v of list) {
      const a = document.createElement("a");
      a.className = "card";
      a.href = ytWatch(v.id);
      a.target = "_blank";
      a.rel = "noopener";

      const desc = normalizeWs((v.description || "").split("\n")[0] || "");
      const shortDesc = desc.length > 110 ? (desc.slice(0, 110) + "…") : desc;

      a.innerHTML = `
        <span class="thumb">
          <img loading="lazy" src="${escapeHtml(v.thumb)}" alt="${escapeHtml(v.title)} thumbnail" />
          <span class="play" aria-hidden="true">
            <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="32" cy="32" r="28" fill="rgba(255,255,255,.90)"/>
              <path d="M27 22.5V41.5L43 32L27 22.5Z" fill="rgba(17,24,39,.95)"/>
            </svg>
          </span>
        </span>
        <div class="meta">
          <h3>${escapeHtml(v.title)}</h3>
          <p class="date">${escapeHtml(fmtDate(v.publishedAt))}</p>
          ${shortDesc ? `<p class="desc">${escapeHtml(shortDesc)}</p>` : ""}
          <div class="pillrow">
            ${v.parsha ? `<span class="pill">${escapeHtml(v.parsha)}</span>` : `<span class="pill">Parsha</span>`}
            <span class="pill">YouTube</span>
          </div>
        </div>
      `;
      grid.appendChild(a);
    }
  }

async function getThisWeeksParsha() {
  // NYC / Diaspora (GeoNames ID 5128581)
  const url = "https://www.hebcal.com/shabbat?cfg=json&geonameid=5128581";
  const r = await fetch(url);
  if (!r.ok) throw new Error("Hebcal fetch failed");

  const j = await r.json();
  const item = (j.items || []).find(it => it.category === "parashat");
  if (!item?.title) return "";

  // "Parashat Beshalach" → "Beshalach"
  return item.title.replace(/^Parashat\s+/i, "").trim();
}

	
  async function load() {
    if (!API_KEY || API_KEY === "PASTE_YOUR_API_KEY_HERE") {
      setStatus("Missing API key", "Paste your key into API_KEY at the top of this file.");
      grid.innerHTML = "";
      empty.style.display = "block";
      count.textContent = "";
      return;
    }

    try {
		const cacheKey = `parshaVideos_v1_${MAX_TO_FETCH}`;
const ttlMs = 60 * 60 * 1000; // 1 hour

const cached = JSON.parse(localStorage.getItem(cacheKey) || "null");
if (cached && Date.now() - cached.t < ttlMs && Array.isArray(cached.data)) {
  parshaVideos = cached.data;
  parshaList = Array.from(new Set(parshaVideos.map(v => v.parsha).filter(Boolean)))
    .sort((a,b) => {
      const ia = PARSHA_ORDER.indexOf(a), ib = PARSHA_ORDER.indexOf(b);
      if (ia !== -1 && ib !== -1) return ia - ib;
      if (ia !== -1) return -1;
      if (ib !== -1) return 1;
      return a.localeCompare(b);
    });

  updateParshaCounts();
 buildParshaDropdown();

// 1) URL wins if ?parsha= is present
const fromUrl = getParshaFromURL();
if (fromUrl) {
  selectParshaFromURL();
} else {
  // 2) Otherwise, try to default to this week's parsha
  try {
    const wk = await getThisWeeksParsha();

    // Match against dropdown options (normalized)
    const opt = [...parshaSel.options].find(
      o => normParsha(o.value) === normParsha(wk)
    );

    if (opt) {
      parshaSel.value = opt.value;
    }
  } catch (e) {
    console.warn("Could not determine current parsha:", e);
  }
}

  setPageTitle();
  updateURLFromSelection();
  applyFilters();

 renderParshaExtras(parshaSel.value || "");


  setStatus("Done (cached)", `Loaded ${parshaVideos.length} Parsha videos across ${parshaList.length} Parshios.`);
  return;
}

      setStatus("Starting…", "Finding uploads playlist");
      const uploadsPlaylistId = await getUploadsPlaylistId();

      setStatus("Loading…", "Fetching all video IDs");
      const ids = await getAllVideoIdsFromPlaylist(uploadsPlaylistId);

      setStatus("Loading…", `Found ${ids.length}. Fetching details…`);
      const details = await getVideoDetails(ids);

      setStatus("Filtering…", "Keeping Parsha videos (by description)");
      parshaVideos = details
        .filter(v => isParshaVideo(v.description))
        .map(v => ({ ...v, parsha: extractParsha(v.description) }))
        .filter(v => !!v.id);

localStorage.setItem(cacheKey, JSON.stringify({ t: Date.now(), data: parshaVideos }));
		
      parshaList = Array.from(new Set(parshaVideos.map(v => v.parsha).filter(Boolean)))
  .sort((a, b) => {
    const ia = PARSHA_ORDER.indexOf(a);
    const ib = PARSHA_ORDER.indexOf(b);

    // Known parshios → Torah order
    if (ia !== -1 && ib !== -1) return ia - ib;

    // Known comes before unknown
    if (ia !== -1) return -1;
    if (ib !== -1) return 1;

    // Fallback alphabetical
    return a.localeCompare(b);
  });

updateParshaCounts();


buildParshaDropdown();
selectParshaFromURL();

setPageTitle();              // ✅ new
updateURLFromSelection();    // ✅ new (normalizes URL)

//renderLinks();
applyFilters();
//renderParshaExtras(selectedParsha);
renderParshaExtras(parshaSel.value || "");

	 

//renderLinks();
//renderParshaExtras(selectedParsha);


      setStatus("Done", `Loaded ${parshaVideos.length} Parsha videos across ${parshaList.length} Parshios.`);
    //  applyFilters();
    } catch (e) {
      setStatus("Error", e.message || String(e));
      grid.innerHTML = "";
      empty.style.display = "block";
      count.textContent = "";
    }
  }

  // Events
  q.addEventListener("input", applyFilters);
  sort.addEventListener("change", applyFilters);
 parshaSel.addEventListener("change", () => {
  updateURLFromSelection();  // ✅ new
  setPageTitle();            // ✅ new
//  renderLinks();
  applyFilters();
  renderParshaExtras(parshaSel.value);
	 
   if (window.matchMedia("(max-width: 780px)").matches) {
    setFiltersOpen(false);
  }
  
});


  clearBtn.addEventListener("click", () => {
  q.value = "";
  sort.value = "new";
  parshaSel.value = "";

  updateURLFromSelection();  // ✅ new
  setPageTitle();            // ✅ new

 // renderLinks();
	renderParshaExtras("");

  applyFilters();
  q.focus();
});


  load();
  
  /* =========================
   INLINE AUDIO PLAYER
   ========================= */
//renderParshaExtras("Noach");

const audioEl = document.getElementById("audioEl");
// ===== Progress bar + seeking support (row-embedded scrubber) =====
let isScrubbing = false;

	let currentHref = "";
	let currentRow = null;

function fmtTime(sec){
  sec = Math.max(0, Math.floor(sec || 0));
  const m = Math.floor(sec / 60);
  const s = String(sec % 60).padStart(2, "0");
  return `${m}:${s}`;
}

// Call this whenever you mark a row as active (playing/paused)
function setActiveRow(row){
  currentRow = row;

  // Initialize scrub UI for this row
  const prog = row?.querySelector(".audioProgress");
  const cur  = row?.querySelector(".audioCur");
  const dur  = row?.querySelector(".audioDur");

  if (prog) prog.value = 0;
  if (cur) cur.textContent = "0:00";
  if (dur) dur.textContent = "0:00";
}

// Update scrubber as audio plays
audioEl.addEventListener("timeupdate", () => {
  if (!currentRow) return;
  if (isScrubbing) return; // ✅ don't fight the user's drag

  const prog = currentRow.querySelector(".audioProgress");
  const cur  = currentRow.querySelector(".audioCur");
  const dur  = currentRow.querySelector(".audioDur");

  const d = audioEl.duration || 0;
  const t = audioEl.currentTime || 0;

  if (cur) cur.textContent = fmtTime(t);
  if (dur) dur.textContent = d ? fmtTime(d) : "0:00";

  if (prog && d) prog.value = String(Math.round((t / d) * 1000));
});

	document.addEventListener("pointerdown", (e) => {
  const r = e.target.closest(".audioProgress");
  if (!r) return;
  isScrubbing = true;
  e.stopPropagation();
}, true);

document.addEventListener("pointerup", (e) => {
  if (!isScrubbing) return;
  isScrubbing = false;
}, true);

// Seek while dragging (responsive). If you prefer only on release, tell me.
document.addEventListener("input", (e) => {
  const r = e.target.closest(".audioProgress");
  if (!r || !currentRow) return;
  if (!currentRow.contains(r)) return;

  const d = audioEl.duration || 0;
  if (!d) return;

  const pct = Number(r.value) / 1000;
  audioEl.currentTime = pct * d;

  // update time text immediately while scrubbing
  const cur = currentRow.querySelector(".audioCur");
  if (cur) cur.textContent = fmtTime(audioEl.currentTime);
});


// Set duration once metadata is known
audioEl.addEventListener("loadedmetadata", () => {
  if (!currentRow) return;
  const dur = currentRow.querySelector(".audioDur");
  if (dur) dur.textContent = audioEl.duration ? fmtTime(audioEl.duration) : "0:00";
});

// Dragging the slider seeks (event delegation so it works after re-render)
document.addEventListener("input", (e) => {
  const r = e.target.closest(".audioProgress");
  if (!r || !currentRow) return;

  // Only seek if slider belongs to the active row
  if (!currentRow.contains(r)) return;

  const d = audioEl.duration || 0;
  if (!d) return;

  const pct = Number(r.value) / 1000;
  audioEl.currentTime = pct * d;
});


function clearRowStates(){
  document.querySelectorAll(".audioLink").forEach(row => {
    row.classList.remove("isPlaying", "isPaused");
  });
}

// Prevent the <a> from navigating when user interacts with the progress slider
document.addEventListener("pointerdown", (e) => {
  const slider = e.target.closest(".audioProgress");
  if (!slider) return;

  e.preventDefault();
  e.stopPropagation();
}, { passive: false });

// Slider interactions should not trigger the <a> row click handler.
// We do NOT preventDefault on mousedown (so dragging works on desktop).
document.addEventListener("mousedown", (e) => {
  if (e.target.closest(".audioProgress")) {
    e.stopPropagation();
  }
});

	
document.addEventListener("click", (e) => {
	if (e.target.closest(".audioProgress")) return; // don't treat slider drag like a play click
 const a = e.target.closest(".audioLink");
if (!a) return;

const href = a.dataset.href;

  // SAME audio clicked again → toggle
  if (currentHref === href) {
    if (audioEl.paused) {
      audioEl.play();
      clearRowStates();
      a.classList.add("isPlaying");
		setActiveRow(a);

    } else {
      audioEl.pause();
      a.classList.remove("isPlaying");
      a.classList.add("isPaused");
    }
    return;
  }

  // DIFFERENT audio clicked
  audioEl.pause();
  audioEl.src = href;
  audioEl.load();
  currentHref = href;

  audioEl.play();
  clearRowStates();
  a.classList.add("isPlaying");
	setActiveRow(a);

});

// When audio ends, reset UI
audioEl.addEventListener("ended", clearRowStates);


/* Reset state when audio ends */
audioEl.addEventListener("ended", () => {
  clearRowStates();
});

function fmtTime(sec){
  if (!isFinite(sec) || sec < 0) return "0:00";
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, "0")}`;
}

function updatePlayingRow(){
  document.querySelectorAll("a.audioLink").forEach(a => {
    a.classList.toggle("isPlaying", a.getAttribute("href") === currentlyPlayingHref);
  });
}

function countParshaAudio(data, parsha) {
  if (!data) return 0;

  if (!parsha || parsha === "All") {
    return Object.values(data).reduce(
      (sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0),
      0
    );
  }

  return Array.isArray(data[parsha]) ? data[parsha].length : 0;
}

function updateAudioCounterFromState() {
  const parsha = getCurrentParsha();

  const shortCount = countParshaAudio(PARSHA_AUDIO, parsha);
  const longCount  = countParshaAudio(PARSHA_IN_DEPTH, parsha);
  const total = shortCount + longCount;

  const wrap = document.getElementById("audioCountWrap");
  const el   = document.getElementById("totalAudioCount");
  if (!wrap || !el) return;

  if (total === 0) {
    wrap.style.display = "none";
    return;
  }

  wrap.style.display = "";

  if (parsha === "All") {
    el.textContent = `Total audio shiurim: ${total}`;
  } else {
    el.textContent = `${parsha}: ${total} audio shiurim`;
  }
}
)();

setTimeout(() => {
  if (!window.SITE_COUNTS?.allShiurim?.breakdown) return;

  window.SITE_COUNTS.allShiurim.breakdown.parsha.video =
    Array.isArray(parshaVideos) ? parshaVideos.length : 0;

  // TEMP: confirm it ran
  console.log("Set parsha video count:", window.SITE_COUNTS.allShiurim.breakdown.parsha.video);
}, 0);

(function ensureParshaCountsReady() {
  try { updateParshaCounts(); } catch {}
  if (!window.__COUNTS_READY__?.parsha) setTimeout(ensureParshaCountsReady, 250);
})();

</script>
</body>
</html>



















































